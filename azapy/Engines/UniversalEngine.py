import numpy as np
import pandas as pd
import time
import scipy.optimize as sopt
import threading
from functools import reduce

from ._RiskEngine import _RiskEngine
from azapy.Util.randomgen import random_simplex

class UniversalEngine(_RiskEngine):
    """
    Cover's (1996) Universal Portfolio
    
    **Attributes**
        * status : `int` - computation status (`0` - success, any other 
          value indicates an error)
        * ww : `pandas.DataFrame` - portfolio weights at each rebalancing 
          date
        * name : `str` - portfolio name
    """
    def __init__(self, mktdata, colname='adjusted', schedule=None,
                 fixing_date=None, freq='M', name='Universal',
                 dirichlet_alpha=None, mc_seed=42):
        """
        Constructor

        Parameters
        ----------
        mktdata : `pandas.DataFrame`, optional
            Historic daily market data for portfolio components in the format
            returned by `azapy.mktData` function. The default is `None`.
        colname : `str`, optional
            Name of the price column from `mktdata` used in the weight's 
            calibration. The default is `'adjusted'`.
        schedule : `azapy.schedule_simple`, optional
            External schedule of fixing dates. If it is `None` then the 
            schedule of fixing dates will be generated internally. 
            The default is `None`.
        fixing_date : `str` date-like, optional
            Most recent fixing date used as reference for building the schedule 
            of fixing dates. Must be a valid past business day present in 
            the `mktdata`. It is relevant only if `schedule` is not `None`.
            The default is `None`.
        freq : `str`, optional
            Rate of return horizon. It could be 
            'Q' for a quarter or 'M' for a month. The default is `'M'`.
        name : `str`, optional
            Portfolio name. The default value is `'Universal'`.
        dirichlet_alpha : `list`, optional
            List of Dirichlet alpha coefficients (to be used by the Dirichlet 
            random number generator). The length must be the same with the
            number of symbols in the portfolio. A possible example is 
            `alpha = [0.5] * n` where `n` is the number of symbols in 
            the portfolio. If `alpha` is set to `None` then a uniform 
            generator in the n-simplex `sum_{k=1}^n x_k = 1` with `x_k >= 0` is
            assumed (it is equivalent with Dirichlet for `alpha=[1] * n`). 
            The default is `None`.
        mc_seed : `int`, optional
            Random number generator seed. The default is `42`.

        Returns
        -------
        The object.
        """
        
        self._ptype_ = 'MultiOptimizer'
        self.ww = None
        self.status = None
        
        self.colname = None
        self.freq = None
        self.schedule = None
        self.name = name
        self.dirichlet_alpha = dirichlet_alpha
        self.rng = np.random.RandomState(mc_seed)
        
        self.verbose = False
        
        self.time_level1 = None
        self.time_level2 = None
        self.time_level3 = None
        
        self.set_mktdata(mktdata, colname, schedule, fixing_date, freq)
        
        
    def _getWeights(self, mc_paths=1000, variance_reduction=True, mc_seed=None,
                    verbose=False):
        """
        (to be depricated)
        
        Returns the portfolio weights for each fixing date. In the last entry 
        (row) are the portfolio weights corresponding to the `fixing_date`.

        Parameters
        ----------
        mc_paths : `int`, optional
            Monte Carlo number of paths. If `variance_reduction` is set to 
            `True` then all possible permutations will be considered. Then the
            total number of MC paths is `mc_path` multiplied with the 
            factorial of the number of symbols in the portfolio. For 
            example, for 7 assets (7! = 5040) the total number of MC paths 
            is `mc_paths * 5040`. The default is 1000.
        variance_reduction : Boolean, optional
            If it is set to `True` then the antithetic variance reduction 
            generated by the all the symbol permutations is deployed.
            The effective number of MC paths will be `mc_path` times the
            factorial of the number of symbols in the portfolio.
            The default is `True`.
        mc_seed : `int`, optinal
            Random number generator seed. If it has a value other than `None`
            the random generator will be reseeded.
            The default value is `None`.

        Returns
        -------
        `pandas.DataFrame`
            Portfolio weights for each fixing date. In the last row are 
            the values corresponding to `fixing_date`.
        """
        self.variance_reduction = variance_reduction
        if mc_seed is not None:
            self.rng = np.random.RandomState(mc_seed)
        _mc_seed = self.rng.randint(0, 2147483648, 1)
        rng = np.random.RandomState(_mc_seed)
        
        bb = pd.DataFrame(random_simplex(rng, self.nsymb, mc_paths, 
                                         variance_reduction, 
                                         self.dirichlet_alpha), 
                          columns=self.rrate.columns)
        pth = (self.rrate @ bb.T).cumprod(axis=0)
        self.norm = pth.sum(axis=1, numeric_only=True)
        self.ww = pth @ bb
        for xx in self.ww.columns:
            self.ww[xx] = self.ww[xx] / self.norm

        self.status = 0
        return self.ww
    
    
    def getWeights(self, mc_paths=10, variance_reduction=True, 
                   nr_batches=16, mc_seed=None, verbose=False):
        """
        Computes the portfolio weights for each fixing date. In the last entry 
        (row) are the portfolio weights corresponding to the `fixing_date`.
        
        Notes
        -----
        If `variance_reduction=True` the total
        number of Monte Carlo simulations is `mc_paths * nr_batches * M!`
        where `M` is the number of portfolio components (symbols). 
        For example, if `mc_paths=10`, `mc_batches=10`, and `M=7` 
        the total number of Monte Carlo simulations is `504,000`.
        This feature should be used with care for portfolios with a
        relatively small number of component.

        Parameters
        ----------
        mc_paths : positive `int`, optional
            Number of simulations per Monte Carlo batch. 
            If `variance_reduction` is set to 
            `True` then all possible permutations between porfolio components 
            will be considered and the total number of simulation will be
            multiplied by `M!` where `M` is the number of portfolio 
            components. The defualt is `10`.
        variance_reduction : Boolean, optional
            If it is set to `True`, then the antithetic variance reduction 
            generated by the all the portfolio components permutations 
            is deployed.
            The effective number of Monte Carlo simulations will be
            multiplied by the
            factorial of the number of symbols in the portfolio.
            The default is `True`.
        nr_batches : positive `int`, optional
            The number of a Monte Carlo batches. 
            The computation is 
            multithreaded, i.e. one batch per thread.
            The default is `16`.
        mc_seed : non negative `int`, optional
            Random number generator seed. If it has a value other than `None`
            the random generator will be reseeded.
            The default value is `None`.
        verbose : Boolean, optional
            Logical flag. Sets the verbose mode. 
            The defualt is `False`.

        Returns
        -------
        `pandas.DataFrame`
            Portfolio weights for each fixing date. In the last row are 
            the values corresponding to `fixing_date`.
        """
        def _weights_batch(mc_seed, nsymb, mc_paths):
            rng = np.random.RandomState(mc_seed)
            
            bb = pd.DataFrame(random_simplex(rng, nsymb, mc_paths,
                                             variance_reduction,
                                             self.dirichlet_alpha), 
                              columns=self.rrate.columns)
            pth = (self.rrate @ bb.T).cumprod(axis=0)
            self._mnorm.append(pth.sum(axis=1, numeric_only=True))
            self._mww.append(pth @ bb)
        
        self.variance_reduction = variance_reduction
        
        if verbose:
            if self.variance_reduction:
                print("nr simulations: "
                    f"{mc_paths * nr_batches * np.math.factorial(self.nsymb)}")
            else:
                print(f"nr simulations: {mc_paths * nr_batches}")
                
        if mc_seed is not None:
            self.rng = np.random.RandomState(mc_seed)
        _mc_seed = self.rng.randint(0, 2147483648, nr_batches)
            
        self._mnorm = []
        self._mww = []
        toc = time.perf_counter()
        th = [threading.Thread(target=_weights_batch, 
                               args=(_mc_seed[k], self.nsymb, mc_paths)) \
              for k in range(nr_batches)]
        for i in range(len(th)):
            th[i].start()
        for i in range(len(th)):
            th[i].join()
        self.time_level1 = time.perf_counter() - toc
        
        if verbose:
            print(f"simulation time: {self.time_level1:f}")
            
        self.norm = reduce(lambda x, y: x.add(y, fill_value=0), self._mnorm)
        self.ww = reduce(lambda x, y: x.add(y, fill_value=0), self._mww)
        for xx in self.ww.columns:
            self.ww[xx] = self.ww[xx] / self.norm

        self.status = 0
        return self.ww
    
        
    def set_mktdata(self, mktdata, colname='adjusted', schedule=None,
                    fixing_date=None, freq='M'):
        """
        Sets historical market data. It will overwrite the choice made in the
        constructor.

        Parameters
        ----------
        mktdata : `pandas.DataFrame`
            Historic daily market data for portfolio components in the format
            returned by `azapy.mktData` function.
        colname : `str`, optional
            Name of the price column from mktdata used in the weight's
            calibration. The default is 'adjusted'.
        schedule : `azapy.schedule_simple`, optional
            External schedule of fixing dates. If it is `None` then the 
            schedule of fixing dates will be generated interanly. 
            The default is `None`.
        fixing_date : `str` date-like, optional
            Most recent fixing date used as reference for building the schedule 
            of fixing dates. Must be a valid past business day present in 
            the `mktdata`. It is relevant only if `schedule` is not `Nana`.
            The default is `None`.
        freq : `str`, optional
            Rate of return horizon. It could be 
            'Q' for a quarter or 'M' for a month. The default is `'M'`.
            
        Returns
        -------
        `None`
        """
        ## add some checks ##
        mktdata = mktdata.pivot(columns='symbol', values=colname)
        if schedule is None:
            if fixing_date is None:
                raise ValueError("fixing_date was not set")
            else:
                fixdate = np.datetime64(fixing_date)
                
            sidx = mktdata.index.get_loc(fixdate)
            period = 63 if freq == 'Q' else 21
            fixidx = list(range(sidx, 0, -period))[::-1]
            mkt = mktdata.iloc[fixidx]
        else:
            fixdate = schedule['Dfix'] 
            sdate = mktdata.index[0]
            edate = mktdata.index[-1]
            fixdate = fixdate[(fixdate >= sdate) & (fixdate <= edate)]
            mkt = mktdata.loc[fixdate]
       
        self.rrate = mkt.pct_change().fillna(0) + 1
        self.nsymb = self.rrate.shape[1]

    
    def _b_func(self, bb, order):
        pstar = (self.rrate.iloc[:order] @ bb).prod(numeric_only=True)

        return -pstar
    
    
    def benchmark(self):
        """
        Returns the BCW (best constant weights) portfolio weights.
        
        Returns
        -------
        `pandas.DataFrame`
            The BCW (best constant weights) portfolio weights.
            Each row represents the weights of a BCW portfolio 
            with maturity given by the index value.
        """
        cst = sopt.LinearConstraint(np.ones(self.nsymb), 1, 1,)
        bounds = [(0, 1) for _ in range(self.nsymb)]
        res = pd.DataFrame(0, 
                           index=self.rrate.index, 
                           columns=['RR'] + self.rrate.columns.to_list())
        for order in range(res.shape[0]):
            sol = sopt.minimize(self._b_func, 
                                x0=np.ones(self.nsymb) / self.nsymb,
                                args=(order + 1),
                                constraints=cst,
                                bounds=bounds,)
            if sol.success:
                res.iloc[order, 0] = -sol.fun
                res.iloc[order, 1:] = sol.x 
            else:
                raise ValueError(f"error status: {res.status} {res.message}")
                
        return res.round(2)
