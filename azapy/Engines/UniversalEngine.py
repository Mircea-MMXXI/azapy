import numpy as np
import pandas as pd
import time
import scipy.optimize as sopt
import threading
from functools import reduce

from ._RiskEngine import _RiskEngine
from azapy.Util.randomgen import random_simplex
from azapy.Util.schedule import schedule_simple


class UniversalEngine(_RiskEngine):
    """
    Cover's (1996) Universal Portfolio
    
    **Attributes**
        * status : `int` - computation status (`0` - success, any other 
          value indicates an error)
        * ww : `pandas.DataFrame` - portfolio weights at each rebalancing 
          date
        * name : `str` - portfolio name
    """
    def __init__(self, mktdata=None, colname='adjusted', freq='M', name='Universal',
                 schedule=None, sdate=None, edate='today', noffset=0, 
                 fixoffset=0, hlength=12, dirichlet_alpha=None, 
                 variance_reduction=True, nr_batches=16, mc_paths=100, 
                 mc_seed=42, verbose=False):
        """
        Constructor

        Parameters
        ----------
        mktdata : `pandas.DataFrame`, optional
            Historic daily market data for portfolio components in the format
            returned by `azapy.mktData` function. The default is `None`.
        colname : `str`, optional
            Name of the price column from `mktdata` used in the weight's 
            calibration. The default is `'adjusted'`.
        freq : `str`, optional
            Rate of return horizon. It could be 
            'Q' for a quarter or 'M' for a month. The default is `'M'`.
        name : `str`, optional
            Portfolio name. The default value is `'Universal'`.
        schedule : `azapy.schedule_simple`, optional
            External schedule of fixing dates. If it is `None` then the 
            fixing schedule will be generated internally. 
            The default is `None`.
        fixoffset : int, optional
            Fixing date as number of business days offset relative to the 
            rebalance date. Must be <=0. It is relevant only is `schedule`=`None`.
            The default is `-1`.
        hlength : `float`, optional
            History length in number of years used for calibration. A 
            fractional number will be rounded to an integer number of months.
            For this model, the value of `hlength` must be as large is possible 
            given the market data length and computational resources.
            The default is `12` years.
        dirichlet_alpha : `list`, optional
            List of Dirichlet alpha coefficients (to be used by the Dirichlet 
            random number generator). The length must be the same with the
            number of symbols in the portfolio. A possible example is 
            `alpha = [0.5] * n` where `n` is the number of symbols in 
            the portfolio. If `alpha` is set to `None` then a uniform 
            generator in the n-simplex `sum_{k=1}^n x_k = 1` with `x_k >= 0` is
            assumed (it is equivalent to Dirichlet for `alpha=[1] * n`). 
            The default is `None`.
        variance_reduction : `Boolean`, optional
            If it is set to `True`, then the antithetic variance reduction 
            generated by the permutations of the portfolio components
            is deployed.
            The effective number of Monte Carlo simulations will be
            multiplied by the
            factorial of the number of symbols in the portfolio.
            The default is `True`.
        nr_batches : positive `int`, optional
            The number of a Monte Carlo batches. 
            Since the computation is multithreaded, a good value could 
            be a multiple of the number of cores.
            The default is `16`.
        mc_paths : positive `int`, optional
            Number of simulations per Monte Carlo batch. 
            If `variance_reduction` is set to 
            `True` then the total number of simulation will be
            multiplied by `M!` where `M` is the number of portfolio 
            components. For example, 7 assets (7! = 5040), 16 baches, 
            of 100 paths will lead to `5040 * 16 * 100 = 8,064,000` numbers of 
            MC simulation paths .
            The default is `100`.
        mc_seed : non negative `int`, optional
            Random number generator seed. If it has a value other than `None`
            the random generator will be reseeded.
            The default value is `42`.
        verbose : `Boolean`, optional
            If it is set to `True`, then various computation messages 
            (meant as warnings) will be printed. The default is `False`.
            
        mc_seed : `int`, optional
            Random number generator seed. The default is `42`.

        Returns
        -------
        The object.
        """
        
        self._ptype_ = 'MultiOptimizer'
        self.ww = None
        self.status = None
        
        self.mktdata = None
        self.colname = colname
        self.freq = freq
        self.schedule = None
        self.sdate = sdate
        self.edate = edate
        self.hlength = None if hlength is None else int(hlength)
        self.noffset = noffset
        self.fixoffset = fixoffset
        
        self.name = name
        self.dirichlet_alpha = dirichlet_alpha
        self.variance_reduction = variance_reduction
        self.nr_batches = nr_batches
        self.mc_paths = mc_paths
        self.rng = np.random.RandomState(mc_seed)
 
        self.time_level1 = None
        self.time_level2 = None
        self.time_level3 = None
        
        self._set_schedule(schedule=schedule)
        if mktdata is not None:
            self.set_mktdata(mktdata)
        self.status = 1 
        self.verbose = verbose
        
    
    def getWeights(self, mktdata=None, dirichlet_alpha=None, 
                   variance_reduction=None, nr_batches=None, mc_paths=None,
                   mc_seed=None, finalonly=True, verbose=False):
        """
        Computes the portfolio weights for each fixing date. In the last entry 
        (row) are the portfolio weights corresponding to the `fixing_date`.
        
        Notes
        -----
        If `variance_reduction=True` the total
        number of Monte Carlo simulations is `mc_paths * nr_batches * M!`
        where `M` is the number of portfolio components (symbols). 
        For example, if `mc_paths=10`, `mc_batches=16`, and `M=7` 
        the total number of Monte Carlo simulations is `806,400`.
        This feature should be used with care for portfolios with a
        relatively small number of component.

        Parameters
        ----------
        mktdata : `pandas.DataFrame`, optional
            The portfolio components historical, prices or rates of return, see
            `'pclose'` definition below.
            If it is not `None`, it will overwrite the set of historical rates
            of return computed in the constructor from `'mktdata'`. 
            The default is `None`. 
        dirichlet_alpha : `list`, optional
            List of Dirichlet alpha coefficients (to be used by the Dirichlet 
            random number generator). The length must be the same with the
            number of symbols in the portfolio. A possible example is 
            `alpha = [0.5] * n` where `n` is the number of symbols in 
            the portfolio. If `alpha` is set to `None` then a uniform 
            generator in the n-simplex `sum_{k=1}^n x_k = 1` with `x_k >= 0` is
            assumed (it is equivalent to Dirichlet for `alpha=[1] * n`). 
            The default is `None`.
        variance_reduction : `Boolean`, optional
            If it is set to `True`, then the antithetic variance reduction 
            generated by the permutations of the portfolio components
            is deployed.
            The effective number of Monte Carlo simulations will be
            multiplied by the
            factorial of the number of symbols in the portfolio.
            The default is `True`.
        nr_batches : positive `int`, optional
            The number of a Monte Carlo batches. 
            Since the computation is multithreaded, a good value could 
            be a multiple of the number of cores.
            The default is `16`.
        mc_paths : positive `int`, optional
            Number of simulations per Monte Carlo batch. 
            If `variance_reduction` is set to 
            `True` then the total number of simulation will be
            multiplied by `M!` where `M` is the number of portfolio 
            components. For example, 7 assets (7! = 5040), 16 baches, 
            of 100 paths will lead to `5040 * 16 * 100 = 8,064,000` numbers of 
            MC simulation paths .
            The default is `100`.
        mc_seed : non negative `int`, optional
            Random number generator seed. If it has a value other than `None`
            the random generator will be reseeded.
            The default value is `None`.
        finalonly : `Boolean`, optional
            If it is `False`, the full schedule of weights is returned. 
            Otherwise, only the prevailing weights are returned. 
            The default is `True`.
        verbose : `Boolean`, optional
            If it is set to `True`, then various computation messages 
            (meant as warnings) will be printed. The default is `False`.

        Returns
        -------
        `pandas.DataFrame`
            Portfolio weights for each fixing date. In the last row are 
            the values corresponding to `fixing_date`.
        """
        if mktdata is not None:
            self.set_mktdata(mktdata)
        if self.mktdata is None:
            raise ValueError("mktdata is not set.")
            
        if dirichlet_alpha is not None:
            self.dirichlet_alpha = dirichlet_alpha
            
        if variance_reduction is not None:
            self.variance_reduction = variance_reduction
            
        if nr_batches is not None:
            self.nr_batches = nr_batches
            
        if mc_paths is not None:
            self.mc_paths = mc_paths
            
        if mc_seed is not None:
            self.rng = np.random.RandomState(mc_seed)
        
        self.verbose = verbose
        
        # thread computation function
        def _weights_batch(mc_seed, nsymb, mc_paths):
            rng = np.random.RandomState(mc_seed)
            
            bb = pd.DataFrame(random_simplex(rng, nsymb, mc_paths,
                                             variance_reduction,
                                             self.dirichlet_alpha), 
                              columns=self.rrate.columns)
            pth = (self.rrate @ bb.T).cumprod(axis=0)
            self._mnorm.append(pth.sum(axis=1, numeric_only=True))
            self._mww.append(pth @ bb)
        # end function
        
        if self.verbose:
            if self.variance_reduction:
                print("nr simulations: "
                      f"{self.mc_paths * self.nr_batches * np.math.factorial(self.nsymb)}")
            else:
                print(f"nr simulations: {self.mc_paths * self.nr_batches}")
                
        _mc_seed = self.rng.randint(0, 2147483648, self.nr_batches)
            
        self._mnorm = []
        self._mww = []
        toc = time.perf_counter()
        th = [threading.Thread(target=_weights_batch, 
                               args=(_mc_seed[k], self.nsymb, self.mc_paths)) \
              for k in range(self.nr_batches)]
        for i in range(len(th)):
            th[i].start()
        for i in range(len(th)):
            th[i].join()
        self.time_level1 = time.perf_counter() - toc
        
        if self.verbose:
            print(f"simulation time: {self.time_level1:f}")
            
        self.norm = reduce(lambda x, y: x.add(y, fill_value=0), self._mnorm)
        self._ww = reduce(lambda x, y: x.add(y, fill_value=0), self._mww)
        for xx in self._ww.columns:
            self._ww[xx] = self._ww[xx] / self.norm

        self.status = 0
        
        self.ww = self._ww.iloc[-1]
        if finalonly:
            return self.ww
        return self._ww
    
     
    def _set_schedule(self, schedule=None, freq=None, sdate=None, 
                      edate=None, noffset=None, fixoffset=None, hlength=None):
        if schedule is not None:
            self.schedule = schedule
            return
        
        if edate is not None:
            self.edate = pd.Timestamp(edate).normalize().tz_localize(None)
        if self.edate is None:
            if self.schedule is not None:
                return
            raise ValueError("edate is not set. Cannot define a schedule")
        else:
            self.edate = pd.Timestamp(self.edate).normalize().tz_localize(None)

        if sdate is not None:
            self.sdate = pd.Timestamp(sdate).normalize().tz_localize(None)
        if self.sdate is None:
            if hlength is not None:
                self.hlength = hlength   
            if self.hlength is None:
                if self.schedule is not None:
                    return
                raise ValueError("Neither sdate nor hlength are set."
                                 " Cannot define a schedule")
            self.sdate = pd.Timestamp(year=self.edate.year - self.hlength,
                                      month=1, 
                                      day=1).normalize().tz_localize(None)
        else:
            self.sdate = pd.Timestamp(self.sdate).normalize().tz_localize(None)
            
        if noffset is not None:
            self.noffset = noffset
        
        if fixoffset is not None:
            self.fixoffset = fixoffset
            
        if freq is not None:
            self.freq = freq
            if self.freq not in {'M', 'Q'}:
                raise ValueError("freq must be M or Q.")
            
        self.schedule = schedule_simple(sdate=self.sdate, edate=self.edate, 
                                        freq=self.freq, noffset=self.noffset, 
                                        fixoffset=self.fixoffset)


    def _build_mktdata(self, mktdata):        
        if isinstance(mktdata, dict):
            lvv = []
            for kk, vv in mktdata.items():
                if 'symbol' in vv.columns:
                    lv = vv
                else:
                    lv = vv.copy()
                    lv['symbol'] = kk
                lvv.append(lv)
            return pd.concat(lvv)
        else:
            return mktdata.copy()
            
    
    def set_mktdata(self, mktdata, colname=None, schedule=None, 
                    freq=None, sdate=None, edate=None, noffset=None, 
                    fixoffset=None, hlength=None):
        """
        Sets historical market data. It will overwrite the choice made in the
        constructor.

        Parameters
        ----------
        mktdata : `pandas.DataFrame`
            Historic daily market data for portfolio components in the format
            returned by `azapy.mktData` function.
        colname : `str`, optional
            Name of the price column from mktdata used in the weight's
            calibration. The default is 'adjusted'.
        schedule : `azapy.schedule_simple`, optional
            External schedule of fixing dates. If it is `None` then the 
            schedule of fixing dates will be generated internally. 
            The default is `None`.
        fixing_date : `str` date-like, optional
            Most recent fixing date used as reference for building the schedule 
            of fixing dates. Must be a valid past business day present in 
            the `mktdata`. It is relevant only if `schedule` is not `Nona`.
            The default is `None`.
        freq : `str`, optional
            Rate of return horizon. It could be 
            `'Q'` for a quarter or `'M'` for a month. The default is `'M'`.
            
        Returns
        -------
        `None`
        """
        if colname is not None:
            self.colname = colname

        if mktdata is not None:
            self.mktdata = self._build_mktdata(mktdata)
        if self.mktdata is None:
            raise ValueError("No mktdata was set.")
 
        mktdata = self.mktdata.pivot(columns='symbol', values=self.colname)
        fixdate = self.schedule['Dfix'] 
        sdate = mktdata.index[0]
        edate = mktdata.index[-1]
        fixdate = fixdate[(fixdate >= sdate) & (fixdate <= edate)]
        mkt = mktdata.loc[fixdate]
       
        self.last_data = mkt.iloc[-1]
        self.rrate = mkt.pct_change().fillna(0) + 1
        self.nsymb = self.rrate.shape[1]

    
    def _b_func(self, bb, order):
        pstar = (self.rrate.iloc[:order] @ bb).prod(numeric_only=True)

        return -pstar
    
    
    def benchmark(self):
        """
        Returns the BCWP (Best Constant Weighted Portfolio) weights.
        
        Returns
        -------
        `pandas.DataFrame`
            The BCWP weights.
            Each row represents the weights of a BCWP
            with maturity given by the index value.
        """
        cst = sopt.LinearConstraint(np.ones(self.nsymb), 1, 1,)
        bounds = [(0, 1) for _ in range(self.nsymb)]
        res = pd.DataFrame(0, 
                           index=self.rrate.index, 
                           columns=['RR'] + self.rrate.columns.to_list())
        for order in range(res.shape[0]):
            sol = sopt.minimize(self._b_func, 
                                x0=np.ones(self.nsymb) / self.nsymb,
                                args=(order + 1),
                                constraints=cst,
                                bounds=bounds,)
            if sol.success:
                res.iloc[order, 0] = -sol.fun
                res.iloc[order, 1:] = sol.x 
            else:
                raise ValueError(f"error status: {res.status} {res.message}")
                
        return res.round(2)
