 
(MV_th_doc_base)= 
# MV-based optimal portfolios

MV stands for *Mean Variance*.
The MV optimal portfolio was
introduced by the economist H.M. Markowitz in 1952. It was the main
body of work that later had triggered the development of
*Modern Portfolio Theory* (MPT).


Variance is the dispersion measure for MV-based optimal portfolio
models, *i.e.*,

\begin{equation*}
	{\rm VAR} = w^T C w,
\end{equation*}

where:

* $w$ is the vector of portfolio weights,
* $C$ is the covariance matrix between portfolio components.

> Note: In our case $C$ is estimated from historical observations of
portfolio components rate of return.

The following portfolio optimization strategies are available:
* Minimization of risk for targeted expected rate of return value,
* Minimum risk portfolio,
* Maximization of expected rate of return for a risk vale generated by a
benchmark portfolio (*e.g.* same risk as equal weighted portfolio),
* Maximization of expected rate of return for fixed risk-aversion factor,
* Maximization of MV-Sharpe ratio,
* Minimization of the inverse of MV-Sharpe ratio.

There are 2 support classes:

* **MVAnalyzer** : computes the portfolio weights and performs in-sample
analysis,
* **Port_MV** : performs portfolio back testing, out-of-sample analysis.
 
[TOP](MV_th_doc_base) 
 
(MVAnalyzer_class)= 
## MVAnalyzer class

Computes the portfolio weights and performs in-sample portfolio analysis.

**Methods:**

* [<span style="color:green">getWeights</span>](MV_Risk_getWeights)
* [<span style="color:green">getRsik</span>](MV_Risk_getRisk)
* [<span style="color:green">getPositions</span>](MV_Risk_getPositions)
* [<span style="color:green">viewFrontiers</span>](MV_Risk_viewFrontiers)
* [<span style="color:green">set_mktdata</span>](MV_Risk_set_mktdata)
* [<span style="color:green">set_rrdata</span>](MV_Risk_set_rrate)
* [<span style="color:green">set_rtype</span>](MV_Risk_set_rtype)
* [<span style="color:green">set_random_seed</span>](MV_Risk_set_random_seed)

Note the following 2 important methods:
* **getWeights** : Computes the optimal portfolio weights.
During its computations the following class members are also set:
  * _risk_ : the value of optimal portfolio variance,
  * _primery_risk_comp_ : redundant (single element list containing the
    optimal portfolio variance),
  * _secondary_risk_comp_ : single element list containing the
  optimal portfolio volatility (square root of variance),
  * _sharpe_ : MV-Sharpe ration if `rtype` is set to `'Shapre'` or `'Sharpe2'`
  otherwise `None`,
  * _RR_ : optimal portfolio expected rate of return.


* **getPositions** : Provides practical information regarding the portfolio
rebalancing delta positions and costs.

### Constructor

```
MVAnalyzer(mktdata=None, colname='adjusted', freq='Q', hlength=3.25,
           calendar=None, rtype='Sharpe', method='ecos')
```

where:

* `mktdata` : `pandas.DataFrame` containing the market data in the format returned by
the function `azapy.readMkT`. The default is `None`. Note: `mktdata` could be loaded
latter.
* `colname` : Name of the price column from `mktdata` used in the weights
calibration. The default is `'adjusted'`.
* `freq` : Rate of returns horizon (portfolio rebalancing period).
It could be `'Q'` for quarter or `'M'` for month. The default is `'Q'`.
* `hlength` : History length in number of years used for calibration.
A fractional number will be rounded to an integer number of months.
The default is `3.25` years.
* `calendar` :  `numpy.busdaycalendar` business days calendar. If it is `None`
then the calendar will be set to NYSE business calendar.
The default is `None`.
* `rtype` : Optimization type:
    - `'Risk'` : minimization of risk for fixed expected rate of return value.
    - `'MinRisk'` : minimum risk portfolio.
    - `'InvNRisk'` : optimal portfolio with the same risk as a benchmark
     portfolio (*e.g.* equal weighted portfolio).
    - `'RiskAverse'` : optimal portfolio for fixed risk-aversion value.
    - `'Sharpe'` : maximization of MV-Sharpe ratio.
    - `'Sharpe2'` : minimization of the inverse MV-Sharpe ratio.

  The default is `'Sharpe'`.
* `method` : QP and SOCP numerical methods. Could be `'ecos'` or `'cvxopt'`.
The default is `'ecos'`.

> Note:
>	* `'ecos'` : is SOCP implementation of **ecos** *(Embedded Cone Solver)*
package. **ecos** dose not provide a python explicit interface to a
QP *(Quadratic Programming)* solver. However, QP problem can be viewed as a
special case of SOCP *(Second Order Cone Programming)*.
>
> * `'cvxopt'` : is the SOCP/QP implantation from **cvxopt** package.
>
> In our cases `'ecos'` is the fastest.
 
[TOP](MV_th_doc_base) 

### Methods:
 
(MV_Risk_getWeights)= 
#### <span style="color:green">getWeights</span>

Computes the optimal portfolio weights.

*Call:*

```
getWeights(rtype=None, mu=None, d=1, mu0=0., aversion=None, ww0=None,
           rrate=None )
```

*Inputs:*

* `rtype` : str, optional;
    Optimization type. If is not `None` it will overwrite the value
    set by the constructor. The default is `None`.
* `mu` : float, optional.
    Targeted portfolio expected rate of return.
    Relevant only if `rtype='Risk'`
    The default is `None`.
* `d` : int, optional;
    Frontier type. Active only if `rtype='Risk'`. A value of `1` will
    trigger the evaluation of optimal portfolio along the efficient
    frontier. Otherwise, it will find the portfolio with the lowest
    rate of return along the inefficient portfolio frontier.
    The default is `1`.
* `mu0` : float, optional;
    Risk-free rate accessible to the investor.
    Relevant only if `rype='Sharpe'` or `rtype='Sharpe2'`.
    The default is `0`.
* `aversion` : float, optional;
    The value of the risk-aversion coefficient.
    Must be positive. Relevant only if `rtype='RiskAvers'`.
    The default is `None`.
* `ww0` : list (also `numpy.array` or `pandas.Series`), optional;
    Targeted portfolio weights.
    Relevant only if `rype='InvNrisk'`.
    Its length must be equal to the number of
    symbols in rrate (mktdata).
    All weights must be >= 0 with sum > 0.
    If it is a list or a `numpy.array` then the weights are assumed to
    by in order of `rrate.columns`. If it is a `pandas.Series` then the index
    should be compatible with the `rrate.columns` or mktdata symbols
    (same symbols, not necessary in the same order).
    If it is `None` then it will be set to equal weights.
    The default is `None`.
* `rrate` : `pandas.DataFrame`, optional;
    The portfolio components historical rates of returns.
    If it is not `None`, it will overwrite the rrate computed in the
    constructor from mktdata. The default is `None`.

*Returns:* `pandas.Series` containing the portfolio weights.

Note: It will set the following class members:
* _risk_
* _primary_risk_comp_
* _secondary_risk_comp_
* _sharpe_
* _RR_
 
Their meanings are [here](MVAnalyzer_class) 
 
[TOP](MV_th_doc_base) 
 
(MV_Risk_getRisk)= 
#### <span style="color:green">getRisk</span>

Computes the risk of a portfolio defined by a set of weights.

*Call:*
```
getRisk(ww, rrate=None)
```

*Inputs:*

* `ww` : List-like of portfolio weights. Its length must be equal to the
number of symbols in `rrate` (`mktdata`). All weights must by $\ge 0$ and
their sum equal to $1$. If it
is a `list` or a `np.array` then the weights are assumed to be in the order
of `rrate.columns`. If it is a `pandas.Series` the index should be compatible
with the `rrate.columns` or `mktdata` symbols (not necessary in the same
order).
* `'rrate'` : `pandas.DataFrame` containing the portfolio components historical
rates of returns. If it is not `None`, it will overwrite the `rrate`
computed by the constructor from `mktdata`. The default is `None`.

*Returns:* The value of the risk measure.

Note: It will set the following class members:
* _risk_
* _primary_risk_comp_
* _secondary_risk_comp_
* _sharpe_
* _RR_
 
Their meanings are [here](MVAnalyzer_class) 
 
[TOP](MV_th_doc_base) 
 
(MV_Risk_getPositions)= 
#### <span style="color:green">getPositions</span>

Computes the rebalanced and delta numbers of shares for each portfolio
component.

*Call:*

```
getPositions(nshares=None, cash=0, ww=None, rtype=None, mu=None, mu0=0.,
             aversion=None, ww0=None, )
```

*Inputs:*

* `nshares` : `panda.Series`, optional;
    Initial number of shares per portfolio component.
    A missing component
    entry will be considered 0. A `None` value assumes that all
    components entries are 0. The name of the components must be
    present in the mrkdata. The default is `None`.
* `cash` : float, optional
    Additional cash to be added to the capital. A
    negative entry assumes a reduction in the total capital
    available for rebalance. The total capital cannot be < 0.
    The default is `0`.
* `ww` : `panda.Series`, optional;
    External overwrite portfolio weights.
    If it not set to `None` these
    weights will overwrite the calibrated.
    The default is `None`.
* `rtype` : str, optional;
    Optimization type. If is not `None` it will overwrite the value
    set by the constructor. The default is `None`.
* `mu` : float, optional
    Targeted portfolio expected rate of return.
    Relevant only if `rtype='Risk'`
    The default is `None`.
* `mu0` : float, optional;
    Risk-free rate accessible to the investor.
    Relevant only if `rype='Sharpe'` or `rtype='Sharpe2'`.
    The default is `0`.
* `aversion` : float, optional;
    The value of the risk-aversion coefficient.
    Must be positive. Relevant only if `rtype='RiskAvers'`.
    The default is `None`.
* `ww0` : list (also `numpy.array` or `pandas.Series`), optional;
    Targeted portfolio weights
    Relevant only if `rype='InvNrisk'`.
    Its length must be equal to the number of
    symbols in market data.
    All weights must be >= 0 with sum > 0.
    If it is a list or a `numpy.array` then the weights are assumed to
    by in order of rrate.columns. If it is a `pandas.Series` then the index
    should be compatible with the `rrate.columns` or mktdata symbols
    (same symbols, not necessary in the same order).
    If it is `None` then it will be set to equal weights.
    The default is `None`.

*Returns:* `pandas.DataFrame` containing the rolling information.

Columns:

* `'old_nsh'` : initial number of shares per portfolio component as well as
additional cash position. These are present in the input.
* `'new_nsh'` : the new number of shares per component plus the  residual
cash (due to the rounding to an integer number of shares). A negative entry
means that the investor needs to add more cash in order to cover for the
number of share  roundups. It has a small value.
* `'diff_nsh'` : delta number of shares - the number of shares that needs to be
both/sold in order to rebalance the portfolio positions.
* `'weights'` : portfolio weights used for rebalance. The `'cash'` entry
is the new portfolio value (invested capital).
* `'prices'` : share prices used for rebalance evaluations.

>Note: Since the prices are closing prices, the rebalance can be executed next
business day. Additional cash slippage may occur due to share price differential
between the previous day closing and  execution time.
 
[TOP](MV_th_doc_base) 
 
(MV_Risk_ViewFrontiers)= 
#### <span style="color:green">viewFrontiers</span>

Produces a graphical representation of the portfolio frontiers.

*Call:*
```
viewFrontiers(minrisk=True, efficient=20, inefficient=20,
              sharpe=True, musharpe=0,
              component=True, randomport=20, inverseN=True,
              maxdivers=False, divers_efficient=0, divers_inefficient=0,
              addport=None, fig_type='RR_risk', **opt):
```
*Inputs:*
* `minrisk` : Boolean fag. If it is `True` then the minimum risk portfolio will
be visible. The default is `True`.
* `efficient` : Number of points along the optimal frontier (equally spaced
	 along the x-axis). The default is `20`.
* `inefficient` : Number of points along the inefficient frontier (equally
	 spaced along the x-axis). The default is `20`.
* `sharpe` : Boolean flag. If it is `True` then the maximum Sharpe portfolio will
be visible. The default is `True`.
* `musharpe` : Risk-free rate value used in the evaluation of generalized
Sharpe ratio. The default is `0`.
* `component` : Boolean flag. If it is `True` then single asset portfolios
are evaluated and added to the plot for reference. The default is `True`.
* `randomport` : Number of portfolios with random weights (inefficient) to be
evaluate and added to the plot for reference. The default is `20`.
* `inverseN` : Boolean flag. If it is `True` then the equal weighted portfolio and
the optimal portfolio with the same dispersion (risk) value are evaluated and
added to the plot. The default is `True`.
`maxdivers`: Boolean fag. If it is `True` then the maximum diversified portfolio
will be visible. The default is `True`.
* `divers_efficient`: Number of points along the diversified efficient frontier
(equally spaced along the rate of return axis). The default is 20.
* `divers_inefficient`: Number of points along the diversified inefficient frontier
(equally spaced along the rate of return axis). The default is 20.
* `addport` : `dict` or `pandas.DataFrame`.
The weights of additional portfolio to be added to the plot.
If it is a `dict` then the keys are the labels, and the values are
list of weights in the order of `rrate.columns`. If it is a
`pandas.DataFrame` the index are the labels, and each row is a set
of weights. The columns names should match the symbols names.
The default is `None`.
* `fig_type` : `str`. Graphical representation format.
    * `'RR_risk'` : expected rate of return vs risk,
    * `'Sharpe_RR'` : sharpe vs expected rate of return,
    * `'Divers_RR'` : diversification vs expected rate of return.

    The default is `'RR_risk'`.
* `opt` : Additonal parameters:
    * `'title'` : The default is 'Portfolio frontiers'
    * `'xlabel'` : The default is
        - `'risk'` if `fig_type='RR_risk'`
        - `'rate of returns'` otherwise
    * `'ylabel'` : The default is
        - `'rate of returns'` if `fig_type='RR_risk'`
        - `'sharpe'` if `fig_type='RR_sharpe'`
        - `'diversification'` if `fig_type=RR_divers`
    * `'tangent'` : Boolean flag. If set to `True` the tangent
        (to sharpe point) is added. It has effect only  if
        `fig_type='RR_risk'`. The default is `True`.
    * `saveto` : `str`.
        File name to save the figure. The extension dictates the format:
        png, pdf, svg, etc. For more details see the `mathplotlib`
        documentation for `savefig`. The default is `None`.
    * `data` : `dict`.
        Numerical data to construct the plot. If it is not `None` it
        will take precedence and no other numerical evaluations will be
        performed. It is meant to produce different plot representations
        without reevaluations. The default is `None`.

*Returns:* Dictionary containing numerical data used to make the plots.
It can be passed back as `data` argument to reconstruct the plots without
reevaluations.
 
[TOP](MV_th_doc_base) 
 
(MV_Risk_set_mktdata)= 
#### <span style="color:green">set_mktdata</span>

Sets historical market data. It will overwrite the choices made in the
constructor.

*Call:*

```
set_mktdata(mktdata, colname='adjusted', freq='Q', hlength=3.25, calendar=None)
```

*Inputs:*

* `mktdata` : `pandas.DataFrame`
Historic daily market data for portfolio components in the format
returned by `azapy.mktData` function.
* `colname` :
Name of the price column from `mktdata` used in the weights
calibration. The default is `'adjusted'`.
* `freq` :
Rate of returns horizon. It could be
`'Q'` for quarter or `'M'` for month. The default is `'Q'`.
* `hlength` :
History length in number of years used for calibration. A
fractional number will be rounded to an integer number of months.
The default is `3.25` years.
* `calendar` : `numpy.busdaycalendar`, optional
Business days calendar. If it is `None`, then the calendar will be set
to NYSE business calendar. The default is `None`.


*Returns:* `None`
 
[TOP](MV_th_doc_base) 
 
(MV_Risk_set_rrate)= 
#### <span style="color:green">set_rrate</span>

Sets portfolio components historical rates of returns.
It will overwrite the value computed by the constructor from `mktdata`.

*Call:*

```
set_rrate(rrate)
```

*Inputs:*

* `rrate` : `pandas.DataFrame`,
portfolio components historical rates of returns, where the
columns are `'date'`, `symbol1`, `symbol2`, etc.


*Returns:* `None`
 
[TOP](MV_th_doc_base) 
 
(MV_Risk_set_rtype)= 
#### <span style="color:green">set_rtype</span>

Sets the optimization type. It will overwrite the value set in the
constructor.

*Call:*

```
set_rtype(rtype)
```

*Inputs:*

* `rtype` : Optimization type.

*Returns:* `None`
 
[TOP](MV_th_doc_base) 
 
(MV_Risk_set_random_seed)= 
#### <span style="color:green">set_random_seed</span>

Sets the seed for Dirichlet random generator used in `viewFrontiers`.

*Call:*

```
set_random_seed(seed=42)
```

*Inputs:*

* `seed` : The random generator seed - in case you want to set it to a weird
value other than 42 :). The default is `42`.

*Returns:* `None`
 
[TOP](MV_th_doc_base) 
 
(MVAnalyzer_class_example)= 

### [Examples](https://github.com/Mircea-MMXXI/azapy/blob/main/scripts/analyzers/MVAnalyzer_examples.py)
```
# Examples
import numpy as np
import pandas as pd
import azapy as az

#=============================================================================
# Collect some market data
mktdir = "../../MkTdata"
sdate = "2012-01-01"
edate = "2021-07-27"
symb = ['GLD', 'TLT', 'XLV', 'IHI', 'PSJ']

mktdata = az.readMkT(symb, sdate=sdate, edate=edate, file_dir=mktdir)

#=============================================================================
# Compute MV-Sharpe optimal portfolio
# build the analyzer object
cr1 = az.MVAnalyzer(mktdata, method='ecos')
# computes Sharpe weights for 0 risk-free rate
ww1 = cr1.getWeights()
# print portfolio characteristics
# primary risk = [variance] (redundant)
# secondary risk = [volatility]
# risk = MV (variance)
# sharpe = MV-Sharpe
RR = cr1.RR
risk = cr1.risk
prim = cr1.primary_risk_comp.copy()
seco = cr1.secondary_risk_comp.copy()
sharpe = cr1.sharpe
print("\nSharpe optimal portfolio\n")
print(f"status {cr1.status}")
print(f"coef {ww1}")
print(f"Secondary risk {seco}")
print(f"Primary risk {prim}")
print(f"Sharpe {sharpe}")
print(f"RR {RR}")
print(f"risk {risk}")

# Test risk by computing the risk of a portfolio with weights ww1
test_risk = cr1.getRisk(ww1)
test_risk_res = pd.DataFrame({'risk': [risk], 'test_risk': [test_risk],
                              'diff': [risk-test_risk]})
print(f"Test for the risk computation\n {test_risk_res}")

# Test the Sharpe weights by estimating an optimal portfolio with
# the same expectd rate of returns.
test_ww1 = cr1.getWeights(rtype='Risk', mu=RR)
ww_comp = pd.DataFrame({"ww1": ww1, "test_ww1": test_ww1,
                        'diff': ww1-test_ww1})
print(f"Test for weights computation\n {ww_comp}")

#=============================================================================
# Frontiers evaluations
print("\nFrontiers evaluations\n")
opt = {'title': "MV-Sharpe Port", 'tangent': True}
print("\n rate of return vs risk representation")
rft = cr1.viewFrontiers(musharpe=0, randomport=100, options=opt)
print("\n Sharpe vs rate of return representation")
rft2 = cr1.viewFrontiers(data=rft, fig_type='Sharpe_RR', options=opt)

#=============================================================================
# Sharpe vs. Sharpe2
# first Sharpe (default rtype)
cr1 = az.MVAnalyzer(mktdata)
ww1 = cr1.getWeights()
RR1 = cr1.RR
risk1 = cr1.risk
prim1 = cr1.primary_risk_comp.copy()
seco1 = cr1.secondary_risk_comp.copy()
sharpe1 = cr1.sharpe
# second Sharpe2
cr2 = az.MVAnalyzer(mktdata, method='ecos')
ww2 = cr2.getWeights(rtype="Sharpe2")
RR2 = cr2.RR
risk2 = cr2.risk
prim2 = cr2.primary_risk_comp
seco2 = cr2.secondary_risk_comp
sharpe2 = cr2.sharpe
# print comparison - must be very close
print("\nSharpe vs. Sharpe2\n")
print(f"status {cr2.status} = {cr1.status}")
ww_comp = pd.DataFrame({"ww2": ww2, "ww1": ww1, "diff": ww2-ww1})
print(f"coef\n {ww_comp}")
seco_comp = pd.DataFrame({"seco2": seco2, "seco1": seco1, "diff": seco2-seco1})
print(f"Secondary risk {seco_comp}")
prim_comp = pd.DataFrame({"prim2": prim2, "prim1": prim1,
                          "diff": prim2-prim1})
print(f"Primary risk\n {prim_comp}")
RR_comp = pd.DataFrame({'RR2': [RR2], 'RR1': [RR1], 'diff': [RR2 - RR1]})
print(f"RR comp\n {RR_comp}")
risk_comp = pd.DataFrame({'risk2': [risk2], 'risk1': [risk1],
                          'diff': [risk2-risk1]})
print(f"risk comp\n {risk_comp}")
sharpe_comp = pd.DataFrame({'sharpe2': [sharpe2], 'sharpe1': [sharpe1],
                            'diff': [sharpe2-sharpe1]})
print(f"Sharpe comp\n {sharpe_comp}")

# # Speed of Sharpe vs Sharpe2 - may take some time
# # please uncomment the lines below
# %timeit cr2.getWeights(rtype='Sharpe')
# %timeit cr2.getWeights(rtype='Sharpe2')

#=============================================================================
# Compute InvNrisk optimal portfolio
cr1 = az.MVAnalyzer(mktdata)
# compute the weights of InvNrisk
ww1 = cr1.getWeights(rtype="InvNrisk")
RR1 = cr1.RR

# Test - compute the optimal portfolio for RR1 targeted rate of return
ww2 = cr1.getWeights(rtype="Risk", mu=RR1)
# print comparison results - must be very close
print("\nInvNrisk\n")
ww_comp = pd.DataFrame({"InvNrisk": ww1, "Optimal": ww2, 'diff': ww1-ww2})
print(f"weights comp\n {ww_comp}")

# Test - compute equal weighted portfolio
ww = np.full(len(symb), 1/len(symb))
ww3 = cr1.getWeights(rtype="InvNrisk", ww0=ww)
# print comparison results - must be identical
ww_comp = pd.DataFrame({"InvNrisk": ww1, "Optimal": ww3, 'diff': ww1-ww3})
print(f"weights comp\n {ww_comp}")

#=============================================================================
# Compute MinRisk optimal portfolio
cr1 = az.MVAnalyzer(mktdata)
# compute the MinRisk portfolio
ww1 = cr1.getWeights(rtype="MinRisk")

# Test - using rtype='Risk' for expected rate of return =min(mu_k)
# should default to 'MinRisk' optimal portfolio
ww2 = cr1.getWeights(rtype="Risk", mu=cr1.muk.min())
# print comparison - should be identical
print("\nMinRisk\n")
ww_comp = pd.DataFrame({"MinRisk": ww1, "Test": ww2, 'diff': ww1-ww2})
print(f"weights comp\n {ww_comp}")

#=============================================================================
# Compute RiskAverse optimal portfolio
# first compute the Sharpe portfolio
cr1 = az.MVAnalyzer(mktdata)
ww1 = cr1.getWeights()
sharpe = cr1.sharpe
risk = cr1.risk
# compute RiskAverse portfolio for Lambda=sharpe
Lambda = sharpe
cr2 = az.MVAnalyzer(mktdata)
ww2 = cr2.getWeights(rtype='RiskAverse', aversion=Lambda)

# comparison - they should be very close
print("\nRiskAverse\n")
risk_comp = pd.DataFrame({'risk': [cr2.risk], 'test': [cr2.RR / Lambda],
                          'Sharpe risk': [risk]})
print(f"risk comp\n {risk_comp}")
ww_comp = pd.DataFrame({'ww1': ww1, 'ww2': ww2, 'diff': ww1-ww2})
print(f"weigths:\n {ww_comp}")

#=============================================================================
# # speed comparisons for different SOCP methods
# # may take some time to complete
# # please uncomment the lines below
# import time
# methods = ['ecos', 'cvxopt']
# xta = {}
# for method in methods:
#     crrx = az.MVAnalyzer(mktdata, method=method)
#     toc = time.perf_counter()
#     wwx = crrx.getWeights()
#     tic = time.perf_counter() - toc
#     print(f"method: {method} time: {tic}")
#     xta[method] = pd.concat([pd.Series([tic], index=["Time"]), wwx])

# res = pd.DataFrame(xta)
# print(res.round(4))

#=============================================================================
# Example of rebalancing positions
cr1 = az.MVAnalyzer(mktdata)

# existing positions and cash
ns = pd.Series(100, index=symb)
cash = 0.

# new positions and rolling info
pos = cr1.getPositions(nshares=ns, cash=0, rtype='Sharpe')
print(f" New position report\n {pos}")
```
 
[TOP](MV_th_doc_base) 
 
(MV_Port_class)= 
## Port_MV class


Out-of-sample (backtesting) simulation of MV optimal portfolio periodically
rebalanced.


**Methods:**

* [<span style="color:green">set_model</span>](MV_Port_set_model)
* [<span style="color:green">port_view</span>](MV_Port_port_view)
* [<span style="color:green">port_view_all</span>](MV_Port_port_view_all)
* [<span style="color:green">port_drawdown</span>](MV_Port_port_drawdown)
* [<span style="color:green">port_perf</span>](MV_Port_port_perf)
* [<span style="color:green">port_annual_returns</span>](MV_Port_port_annual_returns)
* [<span style="color:green">port_monthly_returns</span>](MV_Port_port_monthly_returns)
* [<span style="color:green">port_period_returns</span>](MV_Port_port_period_returns)
* [<span style="color:green">get_nshares</span>](MV_Port_get_nshares)
* [<span style="color:green">get_weights</span>](MV_Port_get_weights)
* [<span style="color:green">get_account</span>](MV_Port_get_account)
* [<span style="color:green">get_mktdata</span>](MV_Port_get_mktdata)


The most important method is **set_model**. It must be called before any
other method.

### Constructor

```
Port_MV(mktdata, symb=None, sdate=None, edate=None, col_price='close',
        col_divd='divd', col_ref='adjusted', col_calib='adjusted',
        pname='Port', pcolname=None, capital=100000, schedule=None,
        freq='Q', noffset=-3, fixoffset=-1, calendar=None)
```


where:

* `mktdata` : `pandas.DataFrame`;
Market data in the format `"symbol"`, `"date"`, `"open"`, `"high"`,
`"low"`, `"close"`, `"volume"`, `"adjusted"`, `"divd"`, `"split"`
(*e.g.* as returned by `azapy.readMkT`).
* `symb` :
List of symbols of portfolio components. All symbols
should be present in `mktdata`. If it is `None`, then `symb` will default
to the full set of symbols present in `mktdata`. The default
is `None`.
* `sdate` : date-like;
Start date for historical simulation. If it is `None`, then `sdate` will
default to the earliest date in `mktdata`. The default is `None`.
* `edate` : date-like;
End date for historical simulation. Must be
greater than  `sdate`. If it is `None`, then `edate` will default
to the latest date in `mktdata`. The default is `None`.
* `col_price` : str;
Column name in the `mktdata` that will be considered
for portfolio aggregation. The default is `'close'`.
* `col_divd` : str;
Column name in the `mktdata` that holds the dividend
information. The default is `'dvid'`.
* `col_ref` : str;
Column name in the `mktdata` that will be used as a price
reference for portfolio components (used for various comparisons and graphs).
The default is `'adjusted'`.
* `col_calib` : str;
Column name in the `mktdata` used for historical weights calibrations.
The default is `'adjusted'`.
* `pname` : str;
The name of the portfolio. The default is `'Port'`.
* `pcolname` : str;
Name of the portfolio price column. If it is `None`, than
`pcolname=pname`. The default is `None`.
* `capital` : float;
Initial portfolio Capital in dollars. The default is `100000`.
* `schedule` : `pandas.DataFrame`;
Rebalancing schedule, with columns for `'Droll'` rolling date and
`'Dfix'` fixing date. If it is `None` than the schedule will be set
using the `freq`, `nsoffset`, `fixoffset`, `hlength` and `calendar`
information. The default is `None`.
* `freq` : str;
Rebalancing frequency. It can be `'Q'` for quarterly or `'M'` for
monthly rebalancing. It is relevant only if schedule
is `None`. The default is `'Q'`.
* `noffset` : int;
Rebalancing date `'Droll'` number of offset business days
relative to the end of the period (quart or month). A positive
value add business days beyond the calendar end of the period while
a negative value subtract business days. It is relevant only if
`schedule` is `None`. The default is `-3`.
* `fixoffset` : int;
fixing date `'Dfix'` number of offset business days relative to
the rebalancing date `'Droll'`. It cane be `0` or negative. It is
relevant only if `schedule` is `None`. The default is `-1`.
* `calendar` : `numpy.busdaycalendar`;
Business calendar. If it is `None`, then it will be set to NYSE
business calendar. The default is `None`.
 
[TOP](MV_th_doc_base) 

### Methods:
 
(MV_Port_set_model)= 
#### <span style="color:green">set_model</span>

Sets model parameters and evaluates portfolio time-series.
It must be called before any other class method.

*Call:*

```
set_model(rtype='Sharpe', mu=None, mu0=0, aversion=None, ww0=None,
          hlength=3.25, method='ecos')
```

*Inputs:*

* `rtype` : str, optional; Optimization type:
    - `'Risk'` : minimization of risk for fixed expected rate of return value.
    - `'MinRisk'` : minimum risk portfolio.
    - `'InvNRisk'` : optimal portfolio with the same risk as a benchmark
     portfolio (*e.g.* equal weighted portfolio).
    - `'RiskAverse'` : optimal portfolio for fixed risk-aversion value.
    - `'Sharpe'` : maximization of MV-Sharpe ratio.
    - `'Sharpe2'` : minimization of the inverse MV-Sharpe ratio.

  The default is `'Sharpe'`.
* `mu` : float, optional;
    Targeted portfolio expected rate of return.
    Relevant only if `rtype='Risk'`
    The default is `None`.
* `mu0` : float, optional;
    Risk-free rate accessible to the investor.
    Relevant only if `rype='Sharpe'` or `rtype='Sharpe2'`.
    The default is `0`.
* `aversion` : float, optional;
    The value of the risk-aversion coefficient.
    Must be positive. Relevant only if `rtype='RiskAvers'`.
    The default is `None`.
* `ww0` : list (also `numpy.array` or `pandas.Series`), optional;
    Targeted portfolio weights.
    Relevant only if `rype='InvNrisk'`.
    Its length must be equal to the number of
    symbols in `rrate` (mktdata).
    All weights must be >= 0 with sum > 0.
    If it is a list or a `numpy.array` then the weights are assumed to
    by in order of `rrate.columns`. If it is a `pandas.Series` then
    the index should be compatible with the `rrate.columns` or mktdata
    symbols (same symbols, not necessary in the same order).
    If it is `None` then it will be set to equal weights.
    The default is `None`.
* `hlength` : float, optional;
    The length in year of the historical calibration period relative
    to 'Dfix'. A fractional number will be rounded to an integer number
    of months. The default is `3.25` years.
* `method` :
QP and SOCP numerical methods.
Could be  `'ecos'` or `'cvxopt'`.
The default is `'ecos'`.

*Returns:* `pandas.DataFrame` containing the portfolio time-series in the format
`'date'`, `'pcolname'`.
 
[TOP](MV_th_doc_base) 
 
(MV_Port_port_view)= 
#### <span style="color:green">port_view</span>

Plots the optimal portfolio time series together with some technical
indicators.

*Call:*

```
port_view(emas=[30, 200], bollinger=False, **randomport)
```

*Inputs:*

* `emas` : `list` of int. List of EMA durations. The default is [30, 200].
* `bollinger` : Boolean flag. If it is set `True` then the Bollinger bands are
added. The default is `False`.    
* `opt` : other parameters
    * `fancy` : Boolean flag.
        - `False` : it uses the matplotlib capabilities.
        - `True` : it uses plotly library for interactive time-series view.

        The default is `False`.
    * `title` : `str`. The plot title. The default is `None`.
    * `xaxis` : `str`. The name of x-axis. The default is `'date'`.
    * `yaxis` : `srt`. The name of y-axis. The default is `None`.
    * `saveto` : `str`.
        The name of the file where to save the plot. The default is `None`.

*Returns:* `pandas.DataFrame` containing the time-series included in the plot.
 
[TOP](MV_th_doc_base) 
 
(MV_Port_port_view_all)= 
#### <span style="color:green">port_view_all</span>

Plots in a relative bases the optimal portfolio and its components time-series.
The components time series prices are designated by the value of
`col_ref` argument in the constructor.

*Call:*

```
port_view_all(sdate=None, edate=None, componly=False, **opt)
```

*Inputs:*

* `sdate` : date-like;
Start date of plotted time-series. If it is `None`,
then `sdate` is set to the earliest date in the time-series.
The default is `None`.
* `edate` : date-like;
End date of plotted time-series. If it is `None`, then `edate`
is set to the most recent date of the time-series.
The default is `None`.
* `componly` : Boolean flag.
    - `True` : only the portfolio components time-series are plotted.
    - `False`: the portfolio and its components times-series are plotted.

    The default is `True`.
* `opt` : Other parameters:
    * `fancy` : Boolean flag.
        - `False` : it uses the pandas plot (matplotlib) capabilities.
        - `True` : it uses plotly library for interactive time-series view.

        The default is `False`.
    * `title` : `str`. The plot title. The default is `None`.
    * `xaxis` : `str`. The name of x-axis. The default is `'date'`.
    * `yaxis` : `srt`. The name of y-axis. The default is `None`.
    * `saveto` : `str`.
        The name of the file where to save the plot. The default is `None`.

*Returns:* `pandas.DataFrame` containing the time-series included in the plot.
 
[TOP](MV_th_doc_base) 
 
(MV_Port_port_drawdown)= 
#### <span style="color:green">port_drawdown</span>

Computes the portfolio drawdowns.

*Call:*

```
port_drawdown(top=5, fancy=False)
```

*Inputs:*

* `top` :
The number of largest drawdown that will be reported.
The default is `5`.
* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported in percent rounded
    to 2 decimals.

*Returns:* `pandas.DataFrame` containing the table of
drawdown events. Columns:
* `'DD'` : drawdown rate,
* `'Date'` : recorded date of the drawdown,
* `'Star'` : start date of the drawdown,
* `'End'` : end date of the drawdown. A `NaN` value indicates that the
drawdown event is in progress and the values of `'DD'` and `'Date'` are
provisional only.
 
[TOP](MV_th_doc_base) 
 
(MV_Port_port_perf)= 
#### <span style="color:green">port_perf</span>

Brief description of optimal portfolio and its components performances
in terms of average historical rate of returns and maximum drawdowns.

*Call:*

```
port_perf(componly=False, fancy=False)
```

*Inputs:*

* `componly` : Boolean flag.
If `True`, only the portfolio components information is reported.
The default is `False`.
* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported in percent rounded
    to 2 decimals.

*Returns:* `pandas.DataFrame` containing the table of
performance information. Columns:
* `'RR'` : annual average rate of returns,
* `'DD'` : maximum rate of drawdown during the simulation period,
* `'Beta'` : `abs(RR/DD)`,
* `'DD_date'` : recorded date of maximum drawdown,
* `'DD_start'` : start date of maximum drawdown,
* `'DD_end'` : end date of maximum drawdown.
 
[TOP](MV_th_doc_base) 
 
(MV_Port_port_annual_returns)= 
#### <span style="color:green">port_annual_returns</span>

Computes optimal portfolio and its components annual (calendar) rates of returns.
The components time series prices used in the estimations are designated by
the value of `col_ref` argument in the constructor.

*Call:*

```
port_annual_returns(withcomp=False, componly=False, fancy=False)
```

*Inputs:*

* `withcomp` : Boolean flag.
If `True`, adds the portfolio components annual returns to the
report. The default is `False`.
* `componly` : Boolean flag.
If `True`, only the portfolio components annual returns
are reported. The default is `False`.
* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported in percent rounded
    to 2 decimals and presented is color style.

*Returns:* `pandas.DataFrame`
 
[TOP](MV_th_doc_base) 
 
(MV_Port_port_monthly_returns)= 
#### <span style="color:green">port_monthly_returns</span>

Computes optimal portfolio and its components monthly (calendar) rate of
returns.

*Call:*

```
port_monthly_returns(withcomp=False, componly=False, fancy=False)
```

*Inputs:*

* `withcomp` : Boolean flag.
If `True`, adds the portfolio components monthly returns to the
report. The default is `False`.
* `componly` : Boolean flag.
If `True`, only the portfolio components monthly returns
are reported. The default is `False`.
* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported in percent rounded
    to 2 decimals and presented is color style.

*Returns:* `pandas.DataFrame`
 
[TOP](MV_th_doc_base) 
 
(MV_Port_port_period_returns)= 
#### <span style="color:green">port_period_returns</span>

Computes the rolling periods rate of returns.

*Call:*

```
port_period_returns(fancy=False)
```

*Inputs:*

* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported in percent rounded
    to 2 decimals.

*Returns:* `pandas.DataFrame`

Each rolling period is indicated by its start date, `Droll`.
For reference, the values of `Dfix` and components weights are
included in the report.
 
[TOP](MV_th_doc_base) 
 
(MV_Port_get_nshares)= 
#### <span style="color:green">get_nshares</span>

Returns the number of shares hold after each rolling date.

*Call:*

```
get_nshares()
```

*Inputs:* None


*Returns:* `pandas.DataFrame`

Each rolling period is indicated by its start date, `Droll`.
 
[TOP](MV_th_doc_base) 
 
(MV_Port_get_weights)= 
#### <span style="color:green">get_weights</span>

Returns the portfolio weights for each rebalancing period.

*Call:*

```
get_weights(fancy=False)
```

*Inputs:*

* `fancy` : Boolean flag with default value `False`.
    - `False` : The values are reported in unaltered algebraic format.
    - `True` : The values are reported in percent rounded
    to 2 decimals.

*Returns:* `pandas.DataFrame`
 
[TOP](MV_th_doc_base) 
 
(MV_Port_get_account)= 
#### <span style="color:green">get_account</span>

Returns additional bookkeeping information regarding rebalancing
(*e.g.* residual cash due the number of shares roundup to an integer,
previous period dividend cash accumulation, etc.)

*Call:*

```
get_account(fancy=False)
```

*Inputs:*

* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported rounded.

*Returns:* `pandas.DataFrame`

Accounting report; each rolling period is identified by `'Droll'`. Columns:

* for each symbol : number of shares hold,
* `'cash_invst'` : cash invested at the beginning of the period,
* `'cash_roll'` : cash rolled to the next period,
* `'cash_divd'` : cash dividend accumulated in the previous period.

> Note: The capital at the beginning of the rolling period is
`'cash_invst'` + `'cash_roll'`. It is also equal to the previous period
value of the shares on the fixing date + `'cash_roll'` + `'cash_divd'`.
There are 2 sources for `'cash_roll'`. The roundup to an integer
number of shares and the shares price differential between
the fixing (computation) and rolling (execution) dates. In general it
has a small positive or negative value.
The finance of the `'cash_roll'` (if it has a negative value) is assumed
to be done separately by the investor.
 
[TOP](MV_th_doc_base) 
 
(MV_Port_get_mktdata)= 
#### <span style="color:green">get_mktdata</span>

Returns the actual market data used for portfolio evaluations.

*Call:*

```
get_mktdata()
```

*Inputs:* None


*Returns:* `pandas.DataFrame`
 
[TOP](MV_th_doc_base) 
 
(MV_Port_class_example)= 

### [Examples](https://github.com/Mircea-MMXXI/azapy/blob/main/scripts/portfolios/Port_MV_examples.py)
```
# Examples
import time
import azapy as az

#=============================================================================
# Collect some market data
mktdir = "../../MkTdata"
sdate = "2012-01-01"
edate = "2021-07-27"
symb = ['GLD', 'TLT', 'XLV', 'IHI', 'PSJ']

mktdata = az.readMkT(symb, sdate=sdate, edate=edate, file_dir=mktdir)

#=============================================================================
# set Port_MV class
p4 = az.Port_MV(mktdata, pname='MVPort')

#=============================================================================
# Compute MV-Sharpe optimal portfolio
tic = time.perf_counter()
port4 = p4.set_model()   
toc = time.perf_counter()
print(f"time Sharpe: {toc-tic}")

ww = p4.get_weights()
p4.port_view()
p4.port_view_all()
p4.port_perf()
p4.port_drawdown(fancy=True)
p4.port_perf(fancy=True)
p4.port_annual_returns()
p4.port_monthly_returns()
p4.get_nshares()
p4.get_account(fancy=True)
        
# Use rtype='Sharpe2' - should be the same results
tic = time.perf_counter()
port4_2 = p4.set_model(rtype='Sharpe2')   
toc = time.perf_counter()
print(f"time Sharpe2: {toc-tic}")

# compare - should be identical
port4.columns = ['Sharpe']
port4_2.columns = ['Sharpe2']
pp = az.Port_Simple([port4, port4_2])
_ = pp.set_model()
_ = pp.port_view_all(componly=(True))


#=============================================================================
# Compute MV optimal portfolio
port4 = p4.set_model(rtype="Risk", mu=0.1)   
ww = p4.get_weights()
p4.port_view()
p4.port_view_all()
p4.port_perf()
p4.port_drawdown(fancy=True)
p4.port_perf(fancy=True)
p4.port_annual_returns()
p4.port_monthly_returns()
p4.get_nshares()
p4.get_account(fancy=True)

#=============================================================================
# Compute minimum MV portfolio
port4 = p4.set_model(rtype="MinRisk")   
ww = p4.get_weights()
p4.port_view()
p4.port_view_all()
p4.port_perf()
p4.port_drawdown(fancy=True)
p4.port_perf(fancy=True)
p4.port_annual_returns()
p4.port_monthly_returns()
p4.get_nshares()
p4.get_account(fancy=True)

#=============================================================================
# Compute optimal portfolio with MV of equal weighted portfolio
port4 = p4.set_model(rtype="InvNrisk")   
ww = p4.get_weights()
p4.port_view()
p4.port_view_all()
p4.port_perf()
p4.port_drawdown(fancy=True)
p4.port_perf(fancy=True)
p4.port_annual_returns()
p4.port_monthly_returns()
p4.get_nshares()
p4.get_account(fancy=True)

#=============================================================================
# Compute MV optimal portfolio for fixed risk-aversion factor
port4 = p4.set_model(rtype="RiskAverse", aversion=0.5)   
ww = p4.get_weights()
p4.port_view()
p4.port_view_all()
p4.port_perf()
p4.port_drawdown(fancy=True)
p4.port_perf(fancy=True)
p4.port_annual_returns()
p4.port_monthly_returns()
p4.port_period_returns()
p4.get_nshares()
p4.get_account(fancy=True)  

#=============================================================================
# # speed comparisons for different SOCP methods
# # may take some time to complete
# # please uncomment the lines below
# methods = ['ecos', 'cvxopt']
# zts = []
# for method in methods:
#     toc = time.perf_counter()
#     zz = p4.set_model(method=method)  
#     tic = time.perf_counter()
#     print(f"{method} time: {tic-toc}")  
#     zz.columns = [method]
#     zts.append(zz)

# # must be identical   
# pp = az.Port_Simple(zts)
# _ = pp.set_model()
# _ = pp.port_view_all(componly=True)
```
 
[TOP](MV_th_doc_base) 
