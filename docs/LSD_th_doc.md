 
(LSD_th_doc_base)= 
# mLSD-based optimal portfolios

LSD stands for *Lower Semi-Deviation*.

**azapy** implements a generalization of LSD,
namely the *m-level LSD* (mLSD).

mLSD dispersion measure is defined as

\begin{equation*}
	{\rm mLSD} = \sum_{l=1}^L {\cal K}_l \times \delta_l^{(2)}
\end{equation*}

where:

* $L$ is the mLSD level,
* $\{{\cal K}_l\}_{l=1,\cdots,L}$ is a set of positive non-increasing
coefficients normalized to unit,
* $\delta_l^{(2)}$ is the l-th order delta-risk of second rank, defined
successively as

\begin{align*}
  \delta_1^{(2)}(r) & = \left\|\left( -{\bar r} \right)^+\right\|_2,
	&\cdots \\
	\delta_l^{(2)}(r) &= \left\|\left( -{\bar r} -\sum_{j=1}^{l-1}\delta_j^{(2)}(r)\right)^+\right\|_2, \\
\end{align*}
where $\left\| \cdot \right\|_2 = \left( E\left[\left| \cdot \right|^2\right]\right)^{1/2}$,
is the $L_2$ norm and $\bar r$ is the detrended rate of return,
${\bar r} = r - E[r]$. In this notation $\delta_1^{(2)}$ is the LSD.

> Note: a possible choice could be $L=3$ and ${\cal K}_l=1/3\ \ \forall l$.

The following portfolio optimization strategies are available:
* Minimization of risk for targeted expected rate of return value,
* Minimum risk portfolio,
* Maximization of expected rate of return for a risk vale generated by a
benchmark portfolio (*e.g.* same risk as equal weighted portfolio),
* Maximization of expected rate of return for fixed risk-aversion factor,
* Maximization of mLSD-Sharpe ratio,
* Minimization of the inverse of mLSD-Sharpe ratio,
* Maximum diversified portfolio <span style="color:blue">(beta version)</span>,
* Maximization of expected rate of return for a diversification factor value
generated by a benchmark portfolio (e.g., same diversification factor as
equal weighted portfolio) <span style="color:blue">(beta version)</span>,
* Maximization of diversification factor for an expected rate of return
generated by a benchmark portfolio (e.g., same diversification factor as
equal weighted portfolio) <span style="color:blue">(beta version)</span>.

__The rigorous mathematical description of these strategies is presented
[here](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4205165).__

There are 2 support classes:

* **LSDAnalyzer** : computes the portfolio weights and performs in-sample
analysis,
* **Port_LSD** : performs portfolio back testing, out-of-sample analysis.
 
[TOP](LSD_th_doc_base) 
 
(LSDAnalyzer_class)= 
## LSDAnalyzer class

Computes the portfolio weights and performs in-sample portfolio analysis.

**Methods:**

* [<span style="color:green">getWeights</span>](LSD_Risk_getWeights)
* [<span style="color:green">getRsik</span>](LSD_Risk_getRisk)
* [<span style="color:green">getPositions</span>](LSD_Risk_getPositions)
* [<span style="color:green">viewFrontiers</span>](LSD_Risk_viewFrontiers)
* [<span style="color:green">set_mktdata</span>](LSD_Risk_set_mktdata)
* [<span style="color:green">set_rrdata</span>](LSD_Risk_set_rrate)
* [<span style="color:green">set_rtype</span>](LSD_Risk_set_rtype)
* [<span style="color:green">set_random_seed</span>](LSD_Risk_set_random_seed)

Note the following 2 important methods:
* **getWeights** : Computes the optimal portfolio weights.
During its computations the following class members are also set:
  * _risk_ : the value of mLSD,
  * _primery_risk_comp_ : the value of $\delta_l^{(2)}$ entering in the
  expression of mLSD,
  * _secondary_risk_comp_ : high order cumulative corrections over
  $\delta_1^{(2)}$ (LSD) in ascending order (note: the first element is 0),
  * _sharpe_ : mLSD-Sharpe ration if `rtype` is set to `'Shapre'` or `'Sharpe2'`
  otherwise `None`,
  * _RR_ : optimal portfolio expected rate of return.
  * _divers_ : diversification factor if `rtype` is set to `'Divers'` or `'MaxDivers'`
  otherwise `None` <span style="color:red">(alpha version)</span>.


* **getPositions** : Provides practical information regarding the portfolio
rebalancing delta positions and costs.

### Constructor

```
LSDAnalyzer(coef=[1.], mktdata=None, colname='adjusted', freq='Q',
            hlength=3.25, calendar=None, rtype='Sharpe', method='ecos')
```

where:

* `coef` : Positive, non-increasing list of mixture coefficients.
The default is [1.].
* `mktdata` : `pandas.DataFrame` containing the market data in the format returned by
the function `azapy.readMkT`. The default is `None`. Note: `mktdata` could be loaded
latter.
* `colname` : Name of the price column from `mktdata` used in the weights
calibration. The default is `'adjusted'`.
* `freq` : Rate of returns horizon (portfolio rebalancing period).
It could be `'Q'` for quarter or `'M'` for month. The default is `'Q'`.
* `hlength` : History length in number of years used for calibration.
A fractional number will be rounded to an integer number of months.
The default is `3.25` (years).
* `calendar` :  `numpy.busdaycalendar`, business days calendar. If it is `None`
then the calendar will be set to NYSE business calendar.
The default is `None`.
* `rtype` : Optimization type:
    - `'Risk'` : minimization of risk for targeted expected rate of return value.
    - `'MinRisk'` : minimum risk portfolio.
    - `'InvNRisk'` : optimal portfolio with the same risk as a benchmark
     portfolio (*e.g.* same risk as equal weighted portfolio).
    - `'RiskAverse'` : optimal portfolio for fixed risk-aversion factor.
    - `'Sharpe'` : maximization of mLSD-Sharpe ratio.
    - `'Sharpe2'` : minimization of the inverse mLSD-Sharpe ratio.
    - `'Divers'` : maximization of diversification factor for targeted expected
    rate of return value <span style="color:red">(alpha version)</span>.
    - `'MaxDivers'` : maximum diversified portfolio <span style="color:red">(alpha version)</span>.

  The default is `'Sharpe'`.
* `method` : Designates the SOCP numerical method.
It could be ``'ecos'`` or ``'cvxopt'``.
The default is `'ecos'`.

> Note:
>	* `'ecos'` : is SOCP implementation of **ecos** *(Embedded Cone Solver)*
package.
> * `'cvxopt'` : is the SOCP implantation from **cvxopt** package.
>
> In our cases `'ecos'` is the fastest.
 
[TOP](LSD_th_doc_base) 

### Methods:
 
(LSD_Risk_getWeights)= 
#### <span style="color:green">getWeights</span>

Computes the optimal portfolio weights.

*Call:*

```
getWeights(rtype=None, mu=None, d=1, mu0=0., aversion=None, ww0=None,
           rrate=None )
```

*Inputs:*

* `rtype` : `str`, optional;
    Optimization type. If is not `None` it will overwrite the value
    set by the constructor. The default is `None`.
* `mu` : `float`, optional;
    Targeted portfolio expected rate of return.
    Relevant only if `rtype='Risk'`
    The default is `None`.
* `d` : `int`, optional;
    Frontier type. Active only if `rtype='Risk'`. A value of `1` will
    trigger the evaluation of optimal portfolio along the efficient
    frontier. Otherwise, it will find the portfolio with the lowest
    rate of return along the inefficient portfolio frontier.
    The default is `1`.
* `mu0` : `float`, optional;
    Risk-free rate accessible to the investor.
    Relevant only if `rype='Sharpe'` or `rtype='Sharpe2'`.
    The default is `0`.
* `aversion` : `float`, optional;
    The value of the risk-aversion coefficient.
    Must be positive. Relevant only if `rtype='RiskAvers'`.
    The default is `None`.
* `ww0` : `list` (also `numpy.array` or `pandas.Series`), optional;
    Targeted portfolio weights.
    Relevant only if `rype='InvNrisk'`.
    Its length must be equal to the number of
    symbols in `rrate` (`mktdata`).
    All weights must be >= 0 with sum > 0.
    If it is a list or a `numpy.array` then the weights are assumed to
    by in order of `rrate.columns`. If it is a `pandas.Series` then the index
    should be compatible with the `rrate.columns` or mktdata symbols
    (same symbols, not necessary in the same order).
    If it is `None` then it will be set to equal weights.
    The default is `None`.
* `rrate` : `pandas.DataFrame`, optional;
    The portfolio components historical rates of returns.
    If it is not `None`, it will overwrite the rrate computed in the
    constructor from mktdata. The default is `None`.

*Returns:* `pandas.Series` containing the portfolio weights.

Note: It will set the following class members:
* _risk_
* _primary_risk_comp_
* _secondary_risk_comp_
* _sharpe_
* _RR_
* _divers_ <span style="color:red">(alpha version)</span>
 
Their meanings are [here](LSDAnalyzer_class) 
 
[TOP](LSD_th_doc_base) 
 
(LSD_Risk_getRisk)= 
#### <span style="color:green">getRisk</span>

Computes the risk of a portfolio defined by a set of weights.

*Call:*
```
getRisk(ww, rrate=None)
```

*Inputs:*

* `ww` : List-like of portfolio weights. Its length must be equal to the
number of symbols in `rrate` (`mktdata`). All weights must by $\ge 0$ and
their sum equal to $1$. If it
is a `list` or a `np.array` then the weights are assumed to be in the order
of `rrate.columns`. If it is a `pandas.Series` the index should be compatible
with the `rrate.columns` or `mktdata` symbols (not necessary in the same
order).
* `'rrate'` : `pandas.DataFrame` containing the portfolio components historical
rates of returns. If it is not `None`, it will overwrite the `rrate`
computed by the constructor from `mktdata`. The default is `None`.

*Returns:* The value of the risk measure.

Note: It will set the following class members:
* _risk_
* _primary_risk_comp_
* _secondary_risk_comp_
* _sharpe_
* _RR_
 
Their meanings are [here](LSDAnalyzer_class) 
 
[TOP](LSD_th_doc_base) 
 
(LSD_Risk_getPositions)= 
#### <span style="color:green">getPositions</span>

Computes the rebalanced and delta numbers of shares for each portfolio
component.

*Call:*

```
getPositions(nshares=None, cash=0, ww=None, rtype=None, mu=None, mu0=0.,
             aversion=None, ww0=None, )
```

*Inputs:*

* `nshares` : `panda.Series`, optional;
    Initial number of shares per portfolio component.
    A missing component
    entry will be considered 0. A `None` value assumes that all
    components entries are 0. The name of the components must be
    present in the mrkdata. The default is `None`.
* `cash` : `float`, optional;
    Additional cash to be added to the capital. A
    negative entry assumes a reduction in the total capital
    available for rebalance. The total capital cannot be < 0.
    The default is `0`.
* `ww` : `panda.Series`, optional;
    External overwrite portfolio weights.
    If it not set to `None` these
    weights will overwrite the calibrated.
    The default is `None`.
* `rtype` : `str`, optional;
    Optimization type. If is not `None` it will overwrite the value
    set by the constructor. The default is `None`.
* `mu` : `float`, optional;
    Targeted portfolio expected rate of return.
    Relevant only if `rtype='Risk'` or `rtype='Divers'`.
    The default is `None`.
* `mu0` : `float`, optional;
    Risk-free rate accessible to the investor.
    Relevant only if `rype='Sharpe'` or `rtype='Sharpe2'`.
    The default is `0`.
* `aversion` : `float`, optional;
    The value of the risk-aversion coefficient.
    Must be positive. Relevant only if `rtype='RiskAvers'`.
    The default is `None`.
* `ww0` : `list` (also `numpy.array` or `pandas.Series`), optional;
    Targeted portfolio weights
    Relevant only if `rype='InvNrisk'`.
    Its length must be equal to the number of
    symbols in market data.
    All weights must be >= 0 with sum > 0.
    If it is a list or a `numpy.array` then the weights are assumed to
    by in order of rrate.columns. If it is a `pandas.Series` then the index
    should be compatible with the `rrate.columns` or mktdata symbols
    (same symbols, not necessary in the same order).
    If it is `None` then it will be set to equal weights.
    The default is `None`.

*Returns:* `pandas.DataFrame` containing the rolling information.

Columns:

* `'old_nsh'` : initial number of shares per portfolio component as well as
additional cash position. These are present in the input.
* `'new_nsh'` : the new number of shares per component plus the  residual
cash (due to the rounding to an integer number of shares). A negative entry
means that the investor needs to add more cash in order to cover for the
number of share  roundups. It has a small value.
* `'diff_nsh'` : delta number of shares - the number of shares that needs to be
both/sold in order to rebalance the portfolio positions.
* `'weights'` : portfolio weights used for rebalance. The `'cash'` entry
is the new portfolio value (invested capital).
* `'prices'` : share prices used for rebalance evaluations.

>Note: Since the prices are closing prices, the rebalance can be executed next
business day. Additional cash slippage may occur due to share price differential
between the previous day closing and  execution time.
 
[TOP](LSD_th_doc_base) 
 
(LSD_Risk_ViewFrontiers)= 
#### <span style="color:green">viewFrontiers</span>

Produces a graphical representation of the portfolio frontiers.

*Call:*
```
viewFrontiers(minrisk=True, efficient=20, inefficient=20,
              sharpe=True, musharpe=0,
              component=True, randomport=20, inverseN=True,
              maxdivers=False, divers_efficient=0, divers_inefficient=0,
              addport=None, fig_type='RR_risk', **opt):
```
*Inputs:*
* `minrisk` : Boolean fag. If it is `True` then the minimum risk portfolio will
be visible. The default is `True`.
* `efficient` : Number of points along the optimal frontier (equally spaced
	 along the x-axis). The default is `20`.
* `inefficient` : Number of points along the inefficient frontier (equally
	 spaced along the x-axis). The default is `20`.
* `sharpe` : Boolean flag. If it is `True` then the maximum Sharpe portfolio will
be visible. The default is `True`.
* `musharpe` : Risk-free rate value used in the evaluation of generalized
Sharpe ratio. The default is `0`.
* `component` : Boolean flag. If it is `True` then single asset portfolios
are evaluated and added to the plot for reference. The default is `True`.
* `randomport` : Number of portfolios with random weights (inefficient) to be
evaluate and added to the plot for reference. The default is `20`.
* `inverseN` : Boolean flag. If it is `True` then the equal weighted portfolio and
the optimal portfolio with the same dispersion (risk) value are evaluated and
added to the plot. The default is `True`.
`maxdivers`: Boolean fag. If it is `True` then the maximum diversified portfolio
will be visible. The default is `True`.
* `divers_efficient`: Number of points along the diversified efficient frontier
(equally spaced along the rate of return axis). The default is 20.
* `divers_inefficient`: Number of points along the diversified inefficient frontier
(equally spaced along the rate of return axis). The default is 20.
* `addport` : `dict` or `pandas.DataFrame`.
The weights of additional portfolio to be added to the plot.
If it is a `dict` then the keys are the labels, and the values are
list of weights in the order of `rrate.columns`. If it is a
`pandas.DataFrame` the index are the labels, and each row is a set
of weights. The columns names should match the symbols names.
The default is `None`.
* `fig_type` : `str`. Graphical representation format.
    * `'RR_risk'` : expected rate of return vs risk,
    * `'Sharpe_RR'` : sharpe vs expected rate of return,
    * `'Divers_RR'` : diversification vs expected rate of return.

    The default is `'RR_risk'`.
* `opt` : Other optional parameters:
    * `'title'` : The default is `"Portfolio frontiers"`
    * `'xlabel'` : The default is
        - `'risk'` if `fig_type='RR_risk'`
        - `'rate of returns'` otherwise
    * `'ylabel'` : The default is
        - `'rate of returns'` if `fig_type='RR_risk'`
        - `'sharpe'` if `fig_type='RR_sharpe'`
        - `'diversification'` if `fig_type=RR_divers`
    * `'tangent'` : Boolean flag. If set to `True` the tangent
        (to sharpe point) is added. It has effect only  if
        `fig_type='RR_risk'`. The default is `True`.
    * `saveto` : `str`.
        File name to save the figure. The extension dictates the format:
        png, pdf, svg, etc. For more details see the `mathplotlib`
        documentation for `savefig`. The default is `None`.
    * `data` : `dict`.
        Numerical data to construct the plot. If it is not `None` it
        will take precedence and no other numerical evaluations will be
        performed. It is meant to produce different plot representations
        without reevaluations. The default is `None`.

*Returns:* Dictionary containing numerical data used to make the plots.
It can be passed back as `data` argument to reconstruct the plots without
reevaluations.
 
[TOP](LSD_th_doc_base) 
 
(LSD_Risk_set_mktdata)= 
#### <span style="color:green">set_mktdata</span>

Sets historical market data. It will overwrite the choices made in the
constructor.

*Call:*

```
set_mktdata(mktdata, colname='adjusted', freq='Q', hlength=3.25, calendar=None)
```

*Inputs:*

* `mktdata` : `pandas.DataFrame`
Historic daily market data for portfolio components in the format
returned by `azapy.mktData` function.
* `colname` : `str`, optional;
Name of the price column from `mktdata` used in the weights
calibration. The default is `'adjusted'`.
* `freq` : `str`, optional;
Rate of returns horizon. It could be
`'Q'` for quarter or `'M'` for month. The default is `'Q'`.
* `hlength` : `float`, optional;
History length in number of years used for calibration. A
fractional number will be rounded to an integer number of months.
The default is `3.25` years.
* `calendar` : `numpy.busdaycalendar`, optional;
Business days calendar. If it is `None`, then the calendar will be set
to NYSE business calendar. The default is `None`.


*Returns:* `None`
 
[TOP](LSD_th_doc_base) 
 
(LSD_Risk_set_rrate)= 
#### <span style="color:green">set_rrate</span>

Sets portfolio components historical rates of returns.
It will overwrite the value computed by the constructor from `mktdata`.

*Call:*

```
set_rrate(rrate)
```

*Inputs:*

* `rrate` : `pandas.DataFrame`;
Portfolio components historical rates of returns. The index name is `'date'` and
columns are `symbol1`, `symbol2`, etc.


*Returns:* `None`
 
[TOP](LSD_th_doc_base) 
 
(LSD_Risk_set_rtype)= 
#### <span style="color:green">set_rtype</span>

Sets the optimization type. It will overwrite the value set in the
constructor.

*Call:*

```
set_rtype(rtype)
```

*Inputs:*

* `rtype` : Optimization type.

*Returns:* `None`
 
[TOP](LSD_th_doc_base) 
 
(LSD_Risk_set_random_seed)= 
#### <span style="color:green">set_random_seed</span>

Sets the seed for Dirichlet random generator used in `viewFrontiers`.

*Call:*

```
set_random_seed(seed=42)
```

*Inputs:*

* `seed` : The random generator seed - in case you want to set it to a weird
value other than 42 :). The default is `42`.

*Returns:* `None`
 
[TOP](LSD_th_doc_base) 
 
(LSDAnalyzer_class_example)= 

### [Examples](https://github.com/Mircea-MMXXI/azapy/blob/main/scripts/analyzers/LSDAnalyzer_examples.py)
```
# Examples
import numpy as np
import pandas as pd
import azapy as az
print(f"azapy version {az.version()} >= 1.1.0", flush=True)

#==============================================================================
# collect market data
mktdir = '../../MkTdata'
sdate = '2012-01-01'
edate = '2021-07-27'
symb = ['GLD', 'TLT', 'XLV', 'IHI', 'PSJ']

mktdata = az.readMkT(symb, sdate=sdate, edate=edate, file_dir=mktdir)

#==============================================================================
# Define mLSD measure parameters
coef = np.full(3, 1/3)
# set now the title of the frontiers plots
title_plot = 'mLSD frontiers'
hlength = 3.25
method = 'ecos' # default choice

# build the analyzer object
cr1 = az.LSDAnalyzer(coef, mktdata, hlength=hlength, method=method)

#==============================================================================
# Beyond this point any section can be run independently 
#==============================================================================
print("\n******************************************************************\n")
print("\n*** Risk of a given portfolio ***")
print("---we choose a random portfolio---")
ww = np.random.dirichlet([0.5] * len(symb))

risk = cr1.getRisk(ww)
status = cr1.status
RR = cr1.RR
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
comp_time = cr1.time_level1
print(f"Risk comp time {comp_time:f}\n "
      f"Portfolio parameters:\nweights {ww.round(4)}\n"
      f"expected rate of return {RR:f}\n"
      f"risk {risk:f}\n"
      f"primary risk comp   {primary_risk.round(6)}\n"
      f"secondary risk comp {secondary_risk.round(6)}\n")

#==============================================================================
print("\n******************************************************************\n")
print("\n*** Diversification + Risk of a given portfolio ***")
print("---we choose a random portfolio---")
ww = np.random.dirichlet([0.5] * len(symb))

diverse = cr1.getDiversification(ww)
status = cr1.status
risk = cr1.risk
RR = cr1.RR
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
comp_time = cr1.time_level1
print(f"Diverse + Risk comp time {comp_time:f}\n "
      f"Portfolio parameters:\nweights {ww.round(4)}\n"
      f"expected rate of return {RR:f}\n"
      f"diversification factor {diverse:f}\n"
      f"risk {risk:f}\n"
      f"primary risk comp   {primary_risk.round(6)}\n"
      f"secondary risk comp {secondary_risk.round(6)}\n")

#==============================================================================
print("\n******************************************************************\n")
print("*** Optimal risk portfolio for targeted expected rate of return ***")
rtype = 'Risk'
mu = 0.04
ww = cr1.getWeights(rtype, mu)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
comp_time = cr1.time_level1

print(f"rtype {rtype} for mu {mu} "
      f"computation status {status} time {comp_time:f}\n"
      f"optimal weights:\n{ww.round(4)}\n"
      f"expected rate of return {RR:f}\n"
      f"risk {risk:f}\n"
      f"primary risk comp   {primary_risk.round(6)}\n"
      f"secondary risk comp {secondary_risk.round(6)}\n")

print("=== test - compute risk for portfolio with optimal weights ===")
print(f"optimal weights\n{ww}")
risk_test = cr1.getRisk(ww)
status_test = cr1.status
RR_test = cr1.RR
risk_test = cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp

prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"rtype {rtype} for mu {mu} computation status {status}\n"
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n"
      f"primary risk comp\n{prc.round(6)}\n"
      f"secondary risk comp\n{src.round(6)}\n")

#==============================================================================
print("\n******************************************************************\n")
print("*** Minimum risk porfolio ***")
rtype = 'MinRisk'
ww = cr1.getWeights(rtype)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
comp_time = cr1.time_level1
print(f"rtype {rtype} computation status {status} comp time {comp_time}\n")

print("=== test - compute optimal risk portfolio for "
      "mu = min component expected rate of return ===")
# results should be identical
rtype_test = 'Risk'
mu = cr1.muk.min()
ww_test = cr1.getWeights(rtype_test, mu)
status_test = cr1.status
RR_test = cr1.RR
risk_test= cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp
comp_time_test = cr1.time_level1
print(f"test rtype {rtype_test} computation status {status_test} "
      f"time {comp_time_test:f}\n")

weights = pd.DataFrame({'ww': ww, 'test': ww_test, 'diff': ww - ww_test})
prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"optimal weigts\n{weights.round(4)}\n" + 
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test}\n"
      f"primary risk comp\n{prc}\n"
      f"secondary risk comp\n{src}\n")

#==============================================================================
print("\n******************************************************************\n")
print("*** Sharpe optimal portfolio - max Sharpe ratio ***")
rtype = 'Sharpe' 
mu0 = 0. # 0. risk free rate (default value)
ww = cr1.getWeights(rtype, mu0=mu0)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
sharpe = cr1.sharpe
comp_time = cr1.time_level1
print(f"rtype {rtype} computation status {status} comp time {comp_time}\n")

print("=== test1 - compute risk for portfolio with Sharpe weights ===")
risk_test = cr1.getRisk(ww)
status_test = cr1.status
ww_test = cr1.ww
RR_test = cr1.RR
risk_test = cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp
weights = pd.DataFrame({'ww': ww, 'test': ww_test, 'diff': ww - ww_test})
comp_time_test = cr1.time_level1
sharpe_test = (RR_test - mu0) / risk_test

prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"test computation status {status_test} comp time {comp_time_test:f}\n\n"
      f"optimal weigts\n{weights.round(4)}\n" 
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n"
      f"sharpe {sharpe:f} test {sharpe_test:f} diff {sharpe - sharpe_test:f}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n"
      f"primary risk comp\n{prc.round(6)}\n"
      f"secondary risk comp\n{src.round(6)}\n")

print("=== test2 - compute optimal risk portfolio for "
      "mu equal to Sharpe portfolio expected rate of return ===")
ww_test = cr1.getWeights('Risk', mu=RR)
status_test = cr1.status
RR_test = cr1.RR
risk_test = cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp
comp_time_test = cr1.time_level1
sharpe_test = (RR_test - mu0) / risk_test
print(f"test computation status {status_test} time {comp_time_test:f}\n")

weights = pd.DataFrame({'ww': ww, 'test': ww_test, 'diff': ww - ww_test})
prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"optimal weigts\n{weights.round(4)}\n" 
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n"
      f"sharpe {sharpe:f} test {sharpe_test:f} diff {sharpe - sharpe_test:f}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n"
      f"primary risk comp\n{prc.round(6)}\n"
      f"secondary risk comp\n{src.round(6)}\n")

#==============================================================================
print("\n******************************************************************\n")
print("*** Sharpe optimal portfolio - min inverse Sharpe ratio ***")
rtype = 'Sharpe2' 
mu0 = 0. # 0. risk free rate (default value)
ww = cr1.getWeights(rtype, mu0=mu0)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
sharpe = cr1.sharpe
comp_time = cr1.time_level1
print(f"rtype {rtype} computation status {status} comp time {comp_time:f}\n")

print("=== test - compare Sharpe with Sharpe2 ===")
rtype_test = 'Sharpe' 
mu0_test = mu0
ww_test = cr1.getWeights(rtype_test, mu0=mu0_test)
status_test = cr1.status
RR_test = cr1.RR
risk_test = cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp
sharpe_test = cr1.sharpe
comp_time_test = cr1.time_level1

weights = pd.DataFrame({'ww': ww, 'test': ww_test, 'diff': ww - ww_test})
prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"rtype {rtype_test} computation status {status_test} "
      f"comp time {comp_time_test:f}\n\n"
      f"optimal weigts\n{weights.round(4)}\n"
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n"
      f"sharpe {sharpe:f} test {sharpe_test:f} diff {sharpe - sharpe_test:f}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n"
      f"primary risk comp\n{prc.round(6)}\n"
      f"secondary risk comp\n{src.round(6)}\n")

#==============================================================================
print("\n******************************************************************\n")
print("*** Optimal risk portfolio for fixed risk-aversion factor ***")
# set the aversion factor equal to Sharpe ratio for mu0=0.
# compute Sharpe portfolio for mu0=0. (default)
rtype_test = 'Sharpe'
ww_test = cr1.getWeights(rtype_test)
status_test = cr1.status
RR_test = cr1.RR
risk_test = cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp
sharpe_test = cr1.sharpe
comp_time_test = cr1.time_level1

# actual computation
rtype = 'RiskAverse'
aversion = np.abs(sharpe_test)
print(f"aversion = Sharpe ratio = {aversion:f}")
ww = cr1.getWeights(rtype, aversion=aversion)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
comp_time = cr1.time_level1
print(f"rtype {rtype} computation status {status} comp time {comp_time:f}\n")

print("=== test - compare optimal risk portfolio for aversion factor equal to "
      "Sharpe ratio ===\n=== (must return the Sharpe portfolio) ===")

weights = pd.DataFrame({'ww': ww, 'test': ww_test, 'diff': ww - ww_test})
prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})

print(f"test rtype {rtype_test} computation status {status_test} " 
      f"comp time {comp_time_test:f}\n\n" 
      f"optimal weigts\n{weights.round(4)}\n" 
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n" 
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n" 
      f"primary risk comp\n{prc.round(6)}\n" 
      f"secondary risk comp\n{src.round(6)}\n")

#==============================================================================
print("\n******************************************************************\n")
print("*** Optimal risk portfolio "
      "with same risk as a benchmark portfolio ***")
print("\t--------------------------------------------------------------------"
      "\n"
      "\tNote: If the benchmark portfolio risk is greater than the risk\n"
      "\tof single asset portfolio with the highest expected rate of return,\n"
      "\tthen the InvNrisk portfolio defaults to this single asset portfolio."
      "\n"
      "\t--------------------------------------------------------------------"
      "\n")
ww0 = np.random.dirichlet([0.5] * len(symb))
# for equal weighted portfolio uncomment the line below
# ww0 = np.full(len(symb), 1/len(symb))
print(f"benchmark portfolio weights {ww0.round(4)}")

rtype = 'InvNrisk'
ww = cr1.getWeights(rtype, ww0=ww0)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
comp_time = cr1.time_level1
print(f"rtype {rtype} computation status {status} comp time {comp_time:f}\n")

print("=== test1 - compare the risk with the benchmark ===")
symb_max = cr1.muk.idxmax()
ww_s = pd.Series(0., index=symb)
ww_s[symb_max] = 1.
risk_s = cr1.getRisk(ww_s)
risk_test = cr1.getRisk(ww0)
if risk_s < risk_test:
    print(f"benchmark port risk {risk_test:f} smaller than {risk_s:f}\n"
          f"default to single asset portfolio {symb_max}")
    risk_test = risk_s
print(f"risk {risk:f} benchmark risk {risk_test:f} diff {risk - risk_test:f}")


print("\n=== test2 - compare with the optimal risk portfolio for "
      "mu = InvNrisk port expected rate of return ===\n"
      "=== must be the same (up to precision) ===")
rtype_test = 'Risk'
mu_test = RR
ww_test = cr1.getWeights(rtype_test, mu=mu_test)
status_test = cr1.status
RR_test = cr1.RR
risk_test = cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp
comp_time_test = cr1.time_level1

weights = pd.DataFrame({'ww': ww, 'test': ww_test, 'diff': ww - ww_test})
prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"rtype {rtype_test:} computation status {status_test} "
      f"comp time {comp_time_test:f}\n\n"
      f"optimal weights\n{weights.round(4)}\n"
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n"
      f"primary risk comp\n{prc.round(6)}\n"
      f"secondary risk comp\n{src.round(6)}\n")

#==============================================================================
print("\n******************************************************************\n")
print("*** Optimal diversified portfolio for targeted "
      "expected rate of return ***")
rtype = 'Diverse'
mu = 0.04
ww = cr1.getWeights(rtype, mu)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
diverse = cr1.diverse
comp_time = cr1.time_level1
print(f"rtype {rtype} computation status {status} comp time {comp_time:f}\n")

print("=== test - compute risk/diversification for a portfolio with weights "
      "equal to the optimal weights ===")
print(f"optimal weights\n{ww.round(4)}")
diverse_test = cr1.getDiversification(ww)
status_test = cr1.status
RR_test = cr1.RR
risk_test = cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp

prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n"
      f"diversification factor {diverse:f} test {diverse_test:f} "
      f"diff {diverse - diverse_test:f}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n"
      f"primary risk comp\n{prc.round(6)}\n"
      f"secondary risk comp\n{src.round(6)}\n")

#==============================================================================
print("\n******************************************************************\n")
print("*** Optimal diversified portfolio for targeted "
      "expected rate of return (alternative) ***")
rtype = 'Diverse2'
mu = 0.04
ww = cr1.getWeights(rtype, mu)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
diverse = cr1.diverse
comp_time = cr1.time_level1
print(f"rtype {rtype} computation status {status} comp time {comp_time:f}\n")

print("=== test - compare rtype 'Diverse2' with 'Diverse' ===")
rtype_test = 'Diverse'
ww_test = cr1.getWeights(rtype_test, mu)
status_test = cr1.status
RR_test = cr1.RR
risk_test = cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp
diverse_test = cr1.diverse
comp_time_test = cr1.time_level1
print(f"rtype {rtype_test} computation status {status_test} "
      f"comp time {comp_time_test:f}\n")

weights = pd.DataFrame({'ww': ww, 'test': ww_test, 'diff': ww - ww_test})
prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"optimal weights\n{weights.round(4)}\n"
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n"
      f"diversification factor {diverse:f} test {diverse_test:f} "
      f"diff {diverse - diverse_test:f}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n"
      f"primary risk comp\n{prc.round(6)}\n"
      f"secondary risk comp\n{src.round(6)}\n")

#==============================================================================
print("\n******************************************************************\n")
print("*** Maximum diversified portfolio ***")
rtype = 'MaxDiverse'
ww = cr1.getWeights(rtype)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
diverse = cr1.diverse
comp_time = cr1.time_level1
print(f"rtype {rtype} computation status {status} comp time {comp_time:f}\n")

print("=== test - compute optimal diversified portfolio for "
      "mu = min component expected rate of return ===")
# results should be identical
rtype_test = 'Diverse'
mu = cr1.muk.min()
ww_test = cr1.getWeights(rtype_test, mu)
status_test = cr1.status
RR_test = cr1.RR
risk_test= cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp
diverse_test = cr1.diverse
comp_time_test = cr1.time_level1
print(f"test rtype {rtype_test} computation status {status_test} "
      f"time {comp_time_test:f}\n")

weights = pd.DataFrame({'ww': ww, 'test': ww_test, 'diff': ww - ww_test})
prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"optimal weigts\n{weights.round(4)}\n" + 
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n"
      f"diversification factor {diverse:f} test {diverse_test:f} "
      f"diff {diverse - diverse_test:f}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n"
      f"primary risk comp\n{prc.round(6)}\n"
      f"secondary risk comp\n{src.round(6)}\n")

#==============================================================================
print("******************************************************************\n")
print("\n*** Optimal diversified portfolio with same diversification "
      "factor as a benchmark portfolio ***")
ww0 = np.random.dirichlet([0.5] * len(symb))
# for equal weighted portfolio uncomment the line below
# ww0 = np.full(len(symb), 1/len(symb))
print(f"benchmark portfolio weights {ww0.round(4)}")

rtype = 'InvNdiverse'
ww = cr1.getWeights(rtype, ww0=ww0)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
comp_time = cr1.time_level1
diverse = cr1.diverse
print(f"rtype {rtype} computation status {status} comp time {comp_time:f}\n")

print("=== test1 - compare the diversification factors ===")
diverse_test = cr1.getDiversification(ww0)
print(f"diversfication {diverse:f} benchmark port {diverse_test:f} "
      f"diff {diverse - diverse_test:f}\n")

print("=== test2 - compare with optimal diversified portfolio for "
      "mu = InvNdiverse portfolio expected rate of return ===")
rtype_test = 'Diverse'
mu_test = RR
ww_test = cr1.getWeights(rtype_test, mu_test)
status_test = cr1.status
RR_test = cr1.RR
risk_test= cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp
diverse_test = cr1.diverse
comp_time_test = cr1.time_level1 
print(f"test rtype {rtype_test} computation status {status_test} "
      f"time {comp_time_test:f}\n")

weights = pd.DataFrame({'ww': ww, 'test': ww_test, 'diff': ww - ww_test})
prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"optimal weights\n{weights.round(4)}\n" + 
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n"
      f"diversification factor {diverse:f} test {diverse_test:f} "
      f"diff {diverse - diverse_test:f}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n"
      f"primary risk comp\n{prc.round(6)}\n"
      f"secondary risk comp\n{src.round(6)}\n")

#==============================================================================
print("******************************************************************\n")
print("\n*** Optimal diversified portfolio with same expected rate of return "
      "as a benchmark portfolio ***")
ww0 = np.random.dirichlet([0.5] * len(symb))
# for equal weighted portfolio uncomment the line below
# ww0 = np.full(len(symb), 1/len(symb))
print(f"benchmark portfolio weights {ww0.round(4)}")

rtype = 'InvNdrr'
ww = cr1.getWeights(rtype, ww0=ww0)
status = cr1.status
RR = cr1.RR
risk = cr1.risk
primary_risk = cr1.primary_risk_comp
secondary_risk = cr1.secondary_risk_comp
comp_time = cr1.time_level1
diverse = cr1.diverse
print(f"rtype {rtype} computation status {status} comp time {comp_time:f}\n")

print("=== test1 - compare the portfolios expected rate of return ===")
_ = cr1.getRisk(ww0)
RR_test = cr1.RR
print(f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n")

print("=== test2 - compare with optimal diversified portfolio for "
      "mu = benchmark portfolio expected rate of return ===")
mu = np.dot(ww0, cr1.muk)
# first compute MaxDiverese portfolio expected rate of return
rtype_test = 'MaxDiverse'
ww_test = cr1.getWeights(rtype_test)
status_test = cr1.status
comp_time_test = cr1.time_level1
print(f"rtype {rtype_test} comp time {comp_time_test:f}")
if status_test == 0:
    mu_maxd = cr1.RR
    # close the branch of the frontiers
    rtype_test = 'Diverse'
    if mu > mu_maxd:
        ww_test = cr1.getWeights(rtype_test, mu, d=1)
        comp_time_test += cr1.time_level1
        print(f"rtype {rtype_test} d=1 comp time {cr1.time_level1:f}\n"
              f"test comp time {comp_time_test:f}")
    elif mu < mu_maxd:
        ww_test = cr1.getWeights(rtype_test, mu, d=-1)
        comp_time_test += cr1.time_level1
        print(f"rtype {rtype_test} d=-1 comp time {cr1.time_level1:f}\n"
              f"test comp time {comp_time_test:f}")
status_test = cr1.status
RR_test = cr1.RR
risk_test= cr1.risk
primary_risk_test = cr1.primary_risk_comp
secondary_risk_test = cr1.secondary_risk_comp
diverse_test = cr1.diverse
print(f"test rtype {rtype_test} computation status {status_test} "
      f"time {comp_time_test:f}\n")

weights = pd.DataFrame({'ww': ww, 'test': ww_test, 'diff': ww - ww_test})
prc = pd.DataFrame({'primary': primary_risk, 'test': primary_risk_test,
                   'diff': primary_risk - primary_risk_test})
src = pd.DataFrame({'secondary': secondary_risk, 'test': secondary_risk_test,
                   'diff': secondary_risk - secondary_risk_test})
print(f"optimal weigts\n{weights.round(4)}\n" + 
      f"expected rate of return {RR:f} test {RR_test:f} diff {RR - RR_test:f}\n"
      f"diversification factor {diverse:f} test {diverse_test:f} "
      f"diff {diverse - diverse_test:f}\n"
      f"risk {risk:f} test {risk_test:f} diff {risk - risk_test:f}\n"
      f"primary risk comp\n{prc.round(6)}\n"
      f"secondary risk comp\n{src.round(6)}\n")

#==============================================================================
print("\n******************************************************************\n")
print("*** Frontiers evaluations - standard view***")
opt = {'title': title_plot, 'tangent': True}
print("\n expected rate of return vs risk representation")
rft = cr1.viewFrontiers(options=opt)
print("\n Sharpe vs expected rate of return representation")
_ = cr1.viewFrontiers(data=rft, fig_type='Sharpe_RR', options=opt)
print("\n diverification factor vs expected rate of return")
_ = cr1.viewFrontiers(data=rft, fig_type='Diverse_RR', options=opt)

#==============================================================================
print("\n******************************************************************\n")
print("*** Frontiers evaluations - custom view***")
# 10 (random in this example) additional portfolios to be added to the plot
rng = np.random.RandomState(42)
addp = {}
for i in range(10):
    addp['p' + str(i+1)] = rng.dirichlet([0.5] * len(symb))
addport = pd.DataFrame().from_dict(addp, 'index', columns=symb)

opt = {'tangent': True, 'title': title_plot, 'minrisk_label': 'mRx', 
       'sharpe_label': 'sharpe', 'addport_label': True, 'xlabel': "RofR"}
print("\n expected rate of return vs risk representation")
fd1 = cr1.viewFrontiers(minrisk=True, efficient=20, inefficient=20, 
                        maxdiverse=True, 
                        diverse_efficient=20, diverse_inefficient=20,
                        invNdiverse=True, invNdrr=True,
                        randomport=10,
                        options=opt, addport=addport)
print("\n Sharpe vs expected rate of return representation")
_ = cr1.viewFrontiers(fig_type='Sharpe_RR', 
                      invNdiverse_label=None, data=fd1, options=opt)
print("\n diverification factor vs expected rate of return")
_ = cr1.viewFrontiers(fig_type='Diverse_RR', 
                      invNrisk_label=None, data=fd1, options=opt)

#==============================================================================
print("\n******************************************************************\n")
print("*** Example of rebalancing positions ***")

# assumed existing positions and cash
ns = pd.Series(100, index=symb)
cash = 0.

# new positions and rolling info
# optimization strategie
rtype = 'Sharpe'
mu0 = 0. # risk free rate

pos = cr1.getPositions(nshares=ns, cash=cash, rtype=rtype, mu0=mu0)
print(f" New position report\n {pos}")

#==============================================================================
print("\n******************************************************************\n")
print("*** Speed comparisons for different methods ***")
# may take some time to complete
# to run please uncomment the lines below
# methods = cr1.methods
# # remove 'interior_point' if exists - it is painfully slow
# if 'interior-point' in methods:
#     methods.remove('interior-point')
# rtypes = cr1.rtypes
# mu = 0.04
# mu0 = 0.
# aversion = 0.6
# ewp = np.full(len(symb), 1/len(symb))

# res_time = pd.DataFrame(0., index=rtypes, columns=methods)
# res_RR = pd.DataFrame(0., index=rtypes, columns=methods)

# for method_ in methods:
#     for rtype_ in rtypes:
#         cr1.set_method(method_)
#         _ = cr1.getWeights(rtype_, mu=mu, mu0=mu0, aversion=aversion, ww0=ewp)
#         print(f"method {method_} rtype {rtype_} status {cr1.status}")
#         res_time.loc[rtype_, method_] = \
#             cr1.time_level1 if cr1.status == 0 else np.nan
#         res_RR.loc[rtype_, method_] = cr1.RR if cr1.status == 0 else np.nan

# print(f"\nComputation time (s) per method per rtype\n{res_time.round(6)}\n")
# print(f"expected rate of return\n{res_RR.round(4)}\n")
# #restore the initial method
# cr1.set_method(method)

#==============================================================================

```
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_class)= 
## Port_LSD class


Out-of-sample (backtesting) simulation of mLSD optimal portfolio periodically
rebalanced.


**Methods:**

* [<span style="color:green">set_model</span>](LSD_Port_set_model)
* [<span style="color:green">port_view</span>](LSD_Port_port_view)
* [<span style="color:green">port_view_all</span>](LSD_Port_port_view_all)
* [<span style="color:green">port_drawdown</span>](LSD_Port_port_drawdown)
* [<span style="color:green">port_perf</span>](LSD_Port_port_perf)
* [<span style="color:green">port_annual_returns</span>](LSD_Port_port_annual_returns)
* [<span style="color:green">port_monthly_returns</span>](LSD_Port_port_monthly_returns)
* [<span style="color:green">port_period_returns</span>](LSD_Port_port_period_returns)
* [<span style="color:green">get_nshares</span>](LSD_Port_get_nshares)
* [<span style="color:green">get_weights</span>](LSD_Port_get_weights)
* [<span style="color:green">get_account</span>](LSD_Port_get_account)
* [<span style="color:green">get_mktdata</span>](LSD_Port_get_mktdata)


The most important method is **set_model**. It must be called before any
other method.

### Constructor

```
Port_LSD(mktdata, symb=None, sdate=None, edate=None, col_price='close',
        col_divd='divd', col_ref='adjusted', col_calib='adjusted',
        pname='Port', pcolname=None, capital=100000, schedule=None,
        freq='Q', noffset=-3, fixoffset=-1, calendar=None)
```


where:

* `mktdata` : `pandas.DataFrame`;
Market data in the format `"symbol"`, `"date"`, `"open"`, `"high"`,
`"low"`, `"close"`, `"volume"`, `"adjusted"`, `"divd"`, `"split"`
(*e.g.* as returned by `azapy.readMkT`).
* `symb` :
List of symbols of portfolio components. All symbols
should be present in `mktdata`. If it is `None`, then `symb` will default
to the full set of symbols present in `mktdata`. The default
is `None`.
* `sdate` : date-like;
Start date for historical simulation. If it is `None`, then `sdate` will
default to the earliest date in `mktdata`. The default is `None`.
* `edate` : date-like;
End date for historical simulation. Must be
greater than  `sdate`. If it is `None`, then `edate` will default
to the latest date in `mktdata`. The default is `None`.
* `col_price` : str;
Column name in the `mktdata` that will be considered
for portfolio aggregation. The default is `'close'`.
* `col_divd` : str;
Column name in the `mktdata` that holds the dividend
information. The default is `'dvid'`.
* `col_ref` : str;
Column name in the `mktdata` that will be used as a price
reference for portfolio components (used for various comparisons and graphs).
The default is `'adjusted'`.
* `col_calib` : str;
Column name in the `mktdata` used for historical weights calibrations.
The default is `'adjusted'`.
* `pname` : str;
The name of the portfolio. The default is `'Port'`.
* `pcolname` : str;
Name of the portfolio price column. If it is `None`, than
`pcolname=pname`. The default is `None`.
* `capital` : float;
Initial portfolio Capital in dollars. The default is `100000`.
* `schedule` : `pandas.DataFrame`;
Rebalancing schedule, with columns for `'Droll'` rolling date and
`'Dfix'` fixing date. If it is `None` than the schedule will be set
using the `freq`, `nsoffset`, `fixoffset`, `hlength` and `calendar`
information. The default is `None`.
* `freq` : str;
Rebalancing frequency. It can be `'Q'` for quarterly or `'M'` for
monthly rebalancing. It is relevant only if schedule
is `None`. The default is `'Q'`.
* `noffset` : int;
Rebalancing date `'Droll'` number of offset business days
relative to the end of the period (quart or month). A positive
value add business days beyond the calendar end of the period while
a negative value subtract business days. It is relevant only if
`schedule` is `None`. The default is `-3`.
* `fixoffset` : int;
fixing date `'Dfix'` number of offset business days relative to
the rebalancing date `'Droll'`. It cane be `0` or negative. It is
relevant only if `schedule` is `None`. The default is `-1`.
* `calendar` : `numpy.busdaycalendar`;
Business calendar. If it is `None`, then it will be set to NYSE
business calendar. The default is `None`.
 
[TOP](LSD_th_doc_base) 

### Methods:
 
(LSD_Port_set_model)= 
#### <span style="color:green">set_model</span>

Sets model parameters and evaluates portfolio time-series.
It must be called before any other class method.


*Call:*

```
set_model(coef=[1.], rtype='Sharpe', mu=None, mu0=0, aversion=None,
          ww0=None, hlength=3.25, method='ecos')
```

*Inputs:*

* `coef` : `list`, optional;
  List of positive non-increasing coefficients.
  The default is `[1.]`.
* `rtype` : `str`, optional; Optimization type:
    - `'Risk'` : minimization of risk for targeted expected rate of return value.
    - `'MinRisk'` : minimum risk portfolio.
    - `'InvNRisk'` : optimal portfolio with the same risk as a benchmark
     portfolio (*e.g.* same risk as equal weighted portfolio).
    - `'RiskAverse'` : optimal portfolio for fixed risk-aversion factor.
    - `'Sharpe'` : maximization of mLSD-Sharpe ratio.
    - `'Sharpe2'` : minimization of the inverse mLSD-Sharpe ratio.
    - `'Divers'` : maximization of diversification factor for targeted expected
    rate of return value <span style="color:red">(alpha version)</span>.
    - `'MaxDivers'` : maximum diversified portfolio <span style="color:red">(alpha version)</span>.

  The default is `'Sharpe'`.
* `mu` : `float`, optional;
    Targeted portfolio expected rate of return.
    Relevant only if `rtype='Risk'`
    The default is `None`.
* `mu0` : `float`, optional;
    Risk-free rate accessible to the investor.
    Relevant only if `rype='Sharpe'` or `rtype='Sharpe2'`.
    The default is `0`.
* `aversion` : `float`, optional;
    The value of the risk-aversion coefficient.
    Must be positive. Relevant only if `rtype='RiskAvers'`.
    The default is `None`.
* `ww0` : `list` (also `numpy.array` or `pandas.Series`), optional;
    Targeted portfolio weights.
    Relevant only if `rype='InvNrisk'`.
    Its length must be equal to the number of
    symbols in `rrate` (mktdata).
    All weights must be >= 0 with sum > 0.
    If it is a list or a `numpy.array` then the weights are assumed to
    by in order of `rrate.columns`. If it is a `pandas.Series` then
    the index should be compatible with the `rrate.columns` or mktdata
    symbols (same symbols, not necessary in the same order).
    If it is `None` then it will be set to equal weights.
    The default is `None`.
* `hlength` : `float`, optional;
    The length in year of the historical calibration period relative
    to 'Dfix'. A fractional number will be rounded to an integer number
    of months. The default is `3.25` years.
* `method` : `str`, optional;
SOCP numerical method.
Could be  `'ecos'` or `'cvxopt'`.
The default is `'ecos'`.

*Returns:* `pandas.DataFrame` containing the portfolio time-series in the format
`'date'`, `'pcolname'`.
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_port_view)= 
#### <span style="color:green">port_view</span>

Plots the optimal portfolio time series together with some technical
indicators.

*Call:*

```
port_view(emas=[30, 200], bollinger=False, **randomport)
```

*Inputs:*

* `emas` : `list` of int, optional; List of EMA durations. The default is [30, 200].
* `bollinger` : `Boolean`, optional; If it is `True` then the Bollinger bands are
added. The default is `False`.    
* `opt` : other parameters
    * `fancy` : `Boolean`, optional;
        - `False` : it uses the matplotlib capabilities.
        - `True` : it uses plotly library for interactive time-series view.

        The default is `False`.
    * `title` : `str`, optional; The plot title. The default is `'Relative performance'`.
    * `xaxis` : `str`, optional; The name of x-axis. The default is `'date'`.
    * `yaxis` : `str`, optional; The name of y-axis. The default is `None`.
    * `saveto` : `str`, optional;
        The name of the file where to save the plot. The default is `None`.

*Returns:* `pandas.DataFrame` containing the time-series included in the plot.
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_port_view_all)= 
#### <span style="color:green">port_view_all</span>

Plots in a relative bases the optimal portfolio and its components time-series.
The components time series prices are designated by the value of
`col_ref` argument in the constructor.

*Call:*

```
port_view_all(sdate=None, edate=None, componly=False, **opt)
```

*Inputs:*

* `sdate` : `date-like`, optional;
Start date of plotted time-series. If it is `None`,
then `sdate` is set to the earliest date in the time-series.
The default is `None`.
* `edate` : `date-like`, optional;
End date of plotted time-series. If it is `None`, then `edate`
is set to the most recent date of the time-series.
The default is `None`.
* `componly` : `Boolean`, optional;
    - `True` : only the portfolio components time-series are plotted.
    - `False`: the portfolio and its components times-series are plotted.

    The default is `True`.
* `opt` : Other parameters:
    * `fancy` : `Boolean`, optional;
        - `False` : it uses the pandas plot (matplotlib) capabilities.
        - `True` : it uses plotly library for interactive time-series view.

        The default is `False`.
    * `title` : `str`, optimal; The plot title. The default is `'Port performance'`.
    * `xaxis` : `str`, optimal; The name of x-axis. The default is `'date'`.
    * `yaxis` : `str`, optimal; The name of y-axis. The default is `None`.
    * `saveto` : `str`, optimal;
        The name of the file where to save the plot. The default is `None`.

*Returns:* `pandas.DataFrame` containing the time-series included in the plot.
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_port_drawdown)= 
#### <span style="color:green">port_drawdown</span>

Computes the portfolio drawdowns.

*Call:*

```
port_drawdown(top=5, fancy=False)
```

*Inputs:*

* `top` :
The number of largest drawdown that will be reported.
The default is `5`.
* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported in percent rounded
    to 2 decimals.

*Returns:* `pandas.DataFrame` containing the table of
drawdown events. Columns:
* `'DD'` : drawdown rate,
* `'Date'` : recorded date of the drawdown,
* `'Star'` : start date of the drawdown,
* `'End'` : end date of the drawdown. A `NaN` value indicates that the
drawdown event is in progress and the values of `'DD'` and `'Date'` are
provisional only.
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_port_perf)= 
#### <span style="color:green">port_perf</span>

Brief description of optimal portfolio and its components performances
in terms of average historical rate of returns and maximum drawdowns.

*Call:*

```
port_perf(componly=False, fancy=False)
```

*Inputs:*

* `componly` : Boolean flag.
If `True`, only the portfolio components information is reported.
The default is `False`.
* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported in percent rounded
    to 2 decimals.

*Returns:* `pandas.DataFrame` containing the table of
performance information. Columns:
* `'RR'` : annual average rate of returns,
* `'DD'` : maximum rate of drawdown during the simulation period,
* `'Beta'` : `abs(RR/DD)`,
* `'DD_date'` : recorded date of maximum drawdown,
* `'DD_start'` : start date of maximum drawdown,
* `'DD_end'` : end date of maximum drawdown.
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_port_annual_returns)= 
#### <span style="color:green">port_annual_returns</span>

Computes optimal portfolio and its components annual (calendar) rates of returns.
The components time series prices used in the estimations are designated by
the value of `col_ref` argument in the constructor.

*Call:*

```
port_annual_returns(withcomp=False, componly=False, fancy=False)
```

*Inputs:*

* `withcomp` : Boolean flag.
If `True`, adds the portfolio components annual returns to the
report. The default is `False`.
* `componly` : Boolean flag.
If `True`, only the portfolio components annual returns
are reported. The default is `False`.
* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported in percent rounded
    to 2 decimals and presented is color style.

*Returns:* `pandas.DataFrame`
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_port_monthly_returns)= 
#### <span style="color:green">port_monthly_returns</span>

Computes optimal portfolio and its components monthly (calendar) rate of
returns.

*Call:*

```
port_monthly_returns(withcomp=False, componly=False, fancy=False)
```

*Inputs:*

* `withcomp` : Boolean flag.
If `True`, adds the portfolio components monthly returns to the
report. The default is `False`.
* `componly` : Boolean flag.
If `True`, only the portfolio components monthly returns
are reported. The default is `False`.
* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported in percent rounded
    to 2 decimals and presented is color style.

*Returns:* `pandas.DataFrame`
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_port_period_returns)= 
#### <span style="color:green">port_period_returns</span>

Computes the rolling periods rate of returns.

*Call:*

```
port_period_returns(fancy=False)
```

*Inputs:*

* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported in percent rounded
    to 2 decimals.

*Returns:* `pandas.DataFrame`

Each rolling period is indicated by its start date, `Droll`.
For reference, the values of `Dfix` and components weights are
included in the report.
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_get_nshares)= 
#### <span style="color:green">get_nshares</span>

Returns the number of shares hold after each rolling date.

*Call:*

```
get_nshares()
```

*Inputs:* None


*Returns:* `pandas.DataFrame`

Each rolling period is indicated by its start date, `Droll`.
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_get_weights)= 
#### <span style="color:green">get_weights</span>

Returns the portfolio weights for each rebalancing period.

*Call:*

```
get_weights(fancy=False)
```

*Inputs:*

* `fancy` : Boolean flag with default value `False`.
    - `False` : The values are reported in unaltered algebraic format.
    - `True` : The values are reported in percent rounded
    to 2 decimals.

*Returns:* `pandas.DataFrame`
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_get_account)= 
#### <span style="color:green">get_account</span>

Returns additional bookkeeping information regarding rebalancing
(*e.g.* residual cash due the number of shares roundup to an integer,
previous period dividend cash accumulation, etc.)

*Call:*

```
get_account(fancy=False)
```

*Inputs:*

* `fancy` : Boolean flag with default value `False`.
    - `False` : the values are reported in unaltered algebraic format.
    - `True` : the values are reported rounded.

*Returns:* `pandas.DataFrame`

Accounting report; each rolling period is identified by `'Droll'`. Columns:

* for each symbol : number of shares hold,
* `'cash_invst'` : cash invested at the beginning of the period,
* `'cash_roll'` : cash rolled to the next period,
* `'cash_divd'` : cash dividend accumulated in the previous period.

> Note: The capital at the beginning of the rolling period is
`'cash_invst'` + `'cash_roll'`. It is also equal to the previous period
value of the shares on the fixing date + `'cash_roll'` + `'cash_divd'`.
There are 2 sources for `'cash_roll'`. The roundup to an integer
number of shares and the shares price differential between
the fixing (computation) and rolling (execution) dates. In general it
has a small positive or negative value.
The finance of the `'cash_roll'` (if it has a negative value) is assumed
to be done separately by the investor.
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_get_mktdata)= 
#### <span style="color:green">get_mktdata</span>

Returns the actual market data used for portfolio evaluations.

*Call:*

```
get_mktdata()
```

*Inputs:* None


*Returns:* `pandas.DataFrame`
 
[TOP](LSD_th_doc_base) 
 
(LSD_Port_class_example)= 

### [Examples](https://github.com/Mircea-MMXXI/azapy/blob/main/scripts/portfolios/Port_LSD_examples.py)
```
# Examples
import pandas as pd 
import azapy as az
print(f"azapy version {az.version()} >= 1.1.0", flush=True)

#==============================================================================
# Collect market data
mktdir = '../../MkTdata'
sdate = '2012-01-01'
edate = 'today'
symb = ['GLD', 'TLT', 'XLV', 'IHI', 'PSJ', 'OIH']

mktdata = az.readMkT(symb, sdate=sdate, edate=edate, file_dir=mktdir)

#==============================================================================
# Define mLSD measure parameters 
maxorder = 3
coef = [1/maxorder] * maxorder
hlength = 1.25
portname = 'mLSD'

# set Port_LSD class
p4 = az.Port_LSD(mktdata, pname=portname)
 
#==============================================================================
# Beyond this point any section can be run independently 
#==============================================================================
# Sharpe optimal portfolio for 0 risk free rate
rtype = 'Sharpe'
mu0 = 0.
port4 = p4.set_model(coef=coef, rtype=rtype, mu0=mu0, hlength=hlength)   

# plots
_ = p4.port_view(title=portname + "-Sharpe", ylabel="price ($)")
_ = p4.port_view_all(title=portname + " Portfolio", ylabel="relative move")

# performance monitoring
performance = p4.port_perf()
drawdowns = p4.port_perf()
aret = p4.port_annual_returns()
mret = p4.port_monthly_returns()
pret = p4.port_period_returns()
with pd.option_context('display.max_columns', None):
    print(f"Performace\n{performance.round(4)}")
    print(f"Portfolio Historical Drowdawns\n{drawdowns.round(4)}")
    print(f"Portfolio Annual Returns\n{aret.round(4)}")
    print(f"Portfolio Monthly Returns\n{mret.round(4)}")
    print(f"Portfolio Period Returns\n{pret.round(2)}")

# accounting information
ww = p4.get_weights()
nshares = p4.get_nshares()
accinfo = p4.get_account()
with pd.option_context('display.max_columns', None):
    print(f"Portfolio Historical Weights\n{ww.round(4)}")
    print(f"Portfolio Numbers of Shares\n{nshares}")
    print(f"Portfolio Rolling Accounting Information\n{accinfo.round(0)}")

#==============================================================================
# compare several standard strategies with equal weighted portfolio
# MaxDiverse - maximum diversified portfolio
# MinRisk - minimum risk portfolio
# Sharpe - maximum generalized Sharpe portfolio
# InvNrisk - optimal-risk portfolio with same risk as EWP
# InvNdrr - optimal-diversified portfolio with 
#           same expected rate of return as EWP
# InvNdiverse - optimal-diversified portfolio with 
#               same diversification factor as EWP
rtypes = ['MaxDiverse', 'MinRisk', 'Sharpe', 
          'InvNrisk', 'InvNdrr', 'InvNdiverse']

port = []
for rtype in rtypes:
    port4 = p4.set_model(coef=coef, rtype=rtype, hlength=hlength)
    port4.columns = [rtype]
    port.append(port4)
    
# add EWP (1/N  portfolio)
p5 = az.Port_ConstW(mktdata, pname="1/N")
port5 = p5.set_model()
port.append(port5)
    
# compare
pp = az.Port_Simple(port)
_ = pp.set_model()
_ = pp.port_view_all(componly=True, 
                     title=portname + " Portfolios - Relative Performance", 
                     xlabel="year")
# compare performances
perfs = pp.port_perf(componly=True)
print(f"Portfolio Performances\n{perfs.round(4)}")
arets = pp.port_annual_returns(withcomp=True, componly=True)
print(f"Annual Returns\n{arets.round(4) * 100}")

#==============================================================================
# Other examples
# Optimal-risk portfolio for fixed aversion factor
rtype = 'RiskAverse'
aversion = 0.4
port4 = p4.set_model(coef=coef, rtype=rtype, aversion=aversion, 
                     hlength=hlength)   

# plots
_ = p4.port_view(title=portname + " aversion = " + str(aversion), 
                 ylabel="price ($)")
_ = p4.port_view_all(title=portname + " Portfolio", ylabel="relative move")

# performance monitoring
performance = p4.port_perf()
drawdowns = p4.port_perf()
aret = p4.port_annual_returns()
mret = p4.port_monthly_returns()
pret = p4.port_period_returns()
with pd.option_context('display.max_columns', None):
    print(f"Performace\n{performance.round(4)}")
    print(f"Portfolio Historical Drowdawns\n{drawdowns.round(4)}")
    print(f"Portfolio Annual Returns\n{aret.round(4)}")
    print(f"Portfolio Monthly Returns\n{mret.round(4)}")
    print(f"Portfolio Period Returns\n{pret.round(2)}")

# accounting information
ww = p4.get_weights()
nshares = p4.get_nshares()
accinfo = p4.get_account()
with pd.option_context('display.max_columns', None):
    print(f"Portfolio Historical Weights\n{ww.round(4)}")
    print(f"Portfolio Numbers of Shares\n{nshares}")
    print(f"Portfolio Rolling Accounting Information\n{accinfo.round(0)}")
    
#==============================================================================
# Optimal-risk portfolio for targeted expected rate of return
rtype = 'Risk'
mu = 0.06
port4 = p4.set_model(coef=coef, rtype=rtype, mu=mu, hlength=hlength)   

# plots
_ = p4.port_view(title=portname + " - Optimal Risk for mu = " + str(mu), 
                 ylabel="price ($)")
_ = p4.port_view_all(title=portname + " Portfolio", ylabel="relative move")

# performance monitoring
performance = p4.port_perf()
drawdowns = p4.port_perf()
aret = p4.port_annual_returns()
mret = p4.port_monthly_returns()
pret = p4.port_period_returns()
with pd.option_context('display.max_columns', None):
    print(f"Performace\n{performance.round(4)}")
    print(f"Portfolio Historical Drowdawns\n{drawdowns.round(4)}")
    print(f"Portfolio Annual Returns\n{aret.round(4)}")
    print(f"Portfolio Monthly Returns\n{mret.round(4)}")
    print(f"Portfolio Period Returns\n{pret.round(2)}")

# accounting information
ww = p4.get_weights()
nshares = p4.get_nshares()
accinfo = p4.get_account()
with pd.option_context('display.max_columns', None):
    print(f"Portfolio Historical Weights\n{ww.round(4)}")
    print(f"Portfolio Numbers of Shares\n{nshares}")
    print(f"Portfolio Rolling Accounting Information\n{accinfo.round(0)}")
    
#==============================================================================
# Optimal-diversified portfolio for targeted expected rate of return
rtype = 'Diverse'
mu = 0.06
port4 = p4.set_model(coef=coef, rtype=rtype, mu=mu, hlength=hlength)   

# plots
_ = p4.port_view(title=portname + " - Optimal Diverse. for mu = " + str(mu), 
                 ylabel="price ($)")
_ = p4.port_view_all(title=portname + " Portfolio", ylabel="relative move")

# performance monitoring
performance = p4.port_perf()
drawdowns = p4.port_perf()
aret = p4.port_annual_returns()
mret = p4.port_monthly_returns()
pret = p4.port_period_returns()
with pd.option_context('display.max_columns', None):
    print(f"Performace\n{performance.round(4)}")
    print(f"Portfolio Historical Drowdawns\n{drawdowns.round(4)}")
    print(f"Portfolio Annual Returns\n{aret.round(4)}")
    print(f"Portfolio Monthly Returns\n{mret.round(4)}")
    print(f"Portfolio Period Returns\n{pret.round(2)}")

# accounting information
ww = p4.get_weights()
nshares = p4.get_nshares()
accinfo = p4.get_account()
with pd.option_context('display.max_columns', None):
    print(f"Portfolio Historical Weights\n{ww.round(4)}")
    print(f"Portfolio Numbers of Shares\n{nshares}")
    print(f"Portfolio Rolling Accounting Information\n{accinfo.round(0)}")
    
#==============================================================================
```
 
[TOP](LSD_th_doc_base) 
